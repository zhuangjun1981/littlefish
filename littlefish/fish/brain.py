# from __future__ import (absolute_import, division,
#                         print_function, unicode_literals)
# from builtins import *

import os
import sys
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import littlefish.utilities as util
import h5py


# consider one time unit is 0.1 milisecond, time unit should be small enough that no more than one action is possible
# per time unit
SIMULATION_LENGTH = int(1e5)  # number of time units in simulation

EYE_GAIN = 0.005
EYE_BASELINE_RATE = 0.
EYE_REFRACTORY_PERIOD = 10
EYE_BORDER_VALUE = 1
EYE_INPUT_FILTER = np.array([0.2, 0.6, 0.2])
EYE2_INPUT_FILTER = np.array([0.15, 0.3, 0.15, 0.1, 0.2, 0.1])
EYE_DIRECTIONS = ['east', 'northeast', 'north', 'northwest', 'west', 'southwest', 'south', 'southeast']
EYE_INPUT_TYPES = ['terrain', 'food', 'fish']

NEURON_REFRACTORY_PERIOD = 10
NEURON_BASELINE_RATE = 0.0001

MUSCLE_DIRECTIONS = ['east', 'north', 'west', 'south']
MUSCLE_REFRACTORY_PERIOD = 5000
MUSCLE_BASELINE_RATE = 0.00001

CONNECTION_LATENCY = 30
CONNECTION_AMPLITUDE = 0.0001
CONNECTION_RISE_TIME = 50
CONNECTION_DECAY_TIME = 100


class Neuron(object):
    """
    a very simple neuron class
    """

    def __init__(self, baseline_rate=NEURON_BASELINE_RATE, refractory_period=NEURON_REFRACTORY_PERIOD):
        """
        action is the equivalent of action potential in biology, and consider one time unit is 0.1 milisecond

        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        self._baseline_rate = float(baseline_rate)
        self._refractory_period = float(refractory_period)
        self._action_history = []

    def __str__(self):
        return 'littlefish.brain.Neuron object'

    def get_baseline_rate(self):
        return self._baseline_rate

    def get_refractory_period(self):
        return self._refractory_period

    def get_action_history(self):
        """
        :return: action_history, list of ints, timing of all actions as indices in time axis of time unit
        """
        return self._action_history

    def set_action_history(self, action_history):

        if not self._action_history:
            print("Brain: overwriting a neuron's action history.")

        self._action_history = action_history

    def reset_action_history(self):
        self._action_history = []

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: bool, True: fire; False: quite
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise(ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                return True
            else:
                return False

    def to_h5_group(self, h5_group):

        h5_group.attrs['baseline_rate_action_per_tu'] = self._baseline_rate
        h5_group.attrs['refractory_period_tu'] = self._refractory_period
        h5_group.attrs['neuron_type'] = 'neuron'
        h5_group.create_dataset('action_history_tu', data=self._action_history)


class Eye(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 1 pixel
    """

    def __init__(self, direction, input_filter=None, gain=None, input_type=None, baseline_rate=None,
                 refractory_period=None):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 3 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        0 0 0 0 0 0 0
        0 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        :param input_type: str, type of the input the eye receives, should be one of 'terrain', 'food', 'fish',
               default: 'terrain'
        """

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise (ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = EYE_INPUT_FILTER
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

        if input_type is None:
            self._input_type = 'terrain'
        elif input_type in ['terrain', 'food', 'fish']:
            self._input_type = input_type
        else:
            raise (ValueError, 'Eye2: type should be one of the following: "terrain", "food", "fish".')

        if baseline_rate is None:
            curr_baseline_rate = EYE_BASELINE_RATE
        else:
            curr_baseline_rate = float(baseline_rate)

        if refractory_period is None:
            curr_refractory_period = EYE_REFRACTORY_PERIOD
        else:
            curr_refractory_period = int(refractory_period)

        super(Eye, self).__init__(baseline_rate=curr_baseline_rate, refractory_period=curr_refractory_period)

    def __str__(self):
        return 'littlefish.brain.Eye object'

    def _get_input_pixels(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the terrain_map
        range will be returned as border_value
        """
        
        if len(position) != 2:
            raise(ValueError, 'position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise(ValueError, 'Elements in position should both be integers.')

        if len(input_map.shape) != 2:
            raise(ValueError, 'terrain_map should a 2-d array.')
        
        if position[0] < 0 or position[0] >= input_map.shape[0] or \
                position[1] < 0 or position[1] >= input_map.shape[1]:
            raise(ValueError, 'position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1]]
        elif self._direction == 'northeast':
            ind = [[position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1]]
        elif self._direction == 'southwest':
            ind = [[position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1]]
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= input_map.shape[0] or cor[1] < 0 or cor[1] >= input_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(input_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(input_map, position, border_value=EYE_BORDER_VALUE)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def act(self, t_point, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param terrain_map: binary 2-d map, for now it should only contain 0s and 1s
        :param border_value: int, default 1, value for pixels outside the terrain_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(input_map, position, border_value=EYE_BORDER_VALUE)

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if random.random() <= curr_rate:
                self._action_history.append(t_point)
                return True
            else:
                return False


class Eye2(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 2 pixels
    """

    def __init__(self, direction, input_filter=None, gain=None, input_type=None, baseline_rate=None,
                 refractory_period=None):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 6 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        3 3 0 0 0 0 0
        3 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        :param input_type: str, type of the input the eye receives, should be one of 'terrain', 'food', 'fish',
               default: 'terrain'
        """

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = EYE2_INPUT_FILTER
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

        if input_type is None:
            self._input_type = 'terrain'
        elif input_type in ['terrain', 'food', 'fish']:
            self._input_type = input_type
        else:
            raise(ValueError, 'Eye2: type should be one of the following: "terrain", "food", "fish".')

        if baseline_rate is None:
            curr_baseline_rate = EYE_BASELINE_RATE
        else:
            curr_baseline_rate = float(baseline_rate)

        if refractory_period is None:
            curr_refractory_period = EYE_REFRACTORY_PERIOD
        else:
            curr_refractory_period = int(refractory_period)

        super(Eye2, self).__init__(baseline_rate=curr_baseline_rate, refractory_period=curr_refractory_period)

    def __str__(self):
        return 'littlefish.brain.Eye2 object'

    def _get_input_pixels(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the terrain_map
        range will be returned as border_value
        """

        if len(position) != 2:
            raise (ValueError, 'Eye2: position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise (ValueError, 'Eye2: Elements in position should both be integers.')

        if len(input_map.shape) != 2:
            raise (ValueError, 'Eye2: terrain_map should a 2-d array.')

        if position[0] < 0 or position[0] >= input_map.shape[0] or \
                position[1] < 0 or position[1] >= input_map.shape[1]:
            raise (ValueError, 'Eye2: position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] + 1, position[1] + 2],
                   [position[0], position[1] + 2],
                   [position[0] - 1, position[1] + 2]]
        elif self._direction == 'northeast':
            ind = [[position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] + 2],
                   [position[0] - 2, position[1] + 2],
                   [position[0] - 2, position[1] + 1]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0] - 2, position[1] + 1],
                   [position[0] - 2, position[1]],
                   [position[0] - 2, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] - 2, position[1] - 1],
                   [position[0] - 2, position[1] - 2],
                   [position[0] - 1, position[1] - 2]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] - 1, position[1] - 2],
                   [position[0], position[1] - 2],
                   [position[0] + 1, position[1] - 2]]
        elif self._direction == 'southwest':
            ind = [[position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] - 2],
                   [position[0] + 2, position[1] - 2],
                   [position[0] + 2, position[1] - 2]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0] + 2, position[1] - 1],
                   [position[0] + 2, position[1]],
                   [position[0] + 2, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] + 2, position[1] + 1],
                   [position[0] + 2, position[1] + 2],
                   [position[0] + 1, position[1] + 2]
                   ]
        else:
            raise (ValueError, "Eye2: direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= input_map.shape[0] or cor[1] < 0 or cor[1] >= input_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(input_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(input_map, position, border_value=border_value)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def get_position(self, body_position):
        """
        :param body_position: tuple of two ints, (row, col)
        :return: eye position given body position accroding its direction
        """
        if len(body_position) != 2:
            raise (ValueError, 'Eye2: body_position should contain two elements.')

        if (not isinstance(body_position[0], int)) or (not isinstance(body_position[1], int)):
            raise (ValueError, 'Eye2: body_position should contain two integers.')

        if self._direction == 'east':
            return body_position[0], body_position[1] + 1
        elif self._direction == 'northeast':
            return body_position[0] - 1, body_position[1] + 1
        elif self._direction == 'north':
            return body_position[0] - 1, body_position[1]
        elif self._direction == 'northwest':
            return body_position[0] - 1, body_position[1] - 1
        elif self._direction == 'west':
            return body_position[0], body_position[1] - 1
        elif self._direction == 'southwest':
            return body_position[0] + 1, body_position[1] - 1
        elif self._direction == 'south':
            return body_position[0] + 1, body_position[1]
        elif self._direction == 'southeast':
            return body_position[0] + 1, body_position[1] + 1
        else:
            raise(ValueError, "Eye2: direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

    def get_input_type(self):
        return self._input_type

    def act(self, t_point, position, input_map, border_value=EYE_BORDER_VALUE, probability_base=None):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param input_map: binary 2-d map, for now it should only contain 0s and 1s
        :param border_value: int, default 1, value for pixels outside the terrain_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(input_map, position, border_value=border_value)

        return super(Eye2, self).act(t_point, probability_input=probability_input, probability_base=probability_base)

        # if probability_base is None:
        #     probability_base = random.random()
        #
        # probability_input = self._get_input(input_map, position, border_value=border_value)
        #
        # if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
        #     return False
        # else:
        #     curr_rate = self._baseline_rate + probability_input
        #     if probability_base <= curr_rate:
        #         self._action_history.append(t_point)
        #         return True
        #     else:
        #         return False

    def to_h5_group(self, h5_group):

        h5_group.attrs['baseline_rate_action_per_tu'] = self._baseline_rate
        h5_group.attrs['refractory_period_tu'] = self._refractory_period
        h5_group.attrs['neuron_type'] = 'eye2'
        h5_group.attrs['direction'] = self._direction
        h5_group.attrs['input_filter'] = self._input_filter
        h5_group.attrs['gain'] = self._gain
        h5_group.attrs['input_type'] = self._input_type
        h5_group.create_dataset('action_history_tu', data=self._action_history)


class Muscle(Neuron):
    """
    muscle class for determining the motion of the fish. Subclass of Neuron class
    """

    def __init__(self, direction, baseline_rate=MUSCLE_BASELINE_RATE, refractory_period=MUSCLE_REFRACTORY_PERIOD):

        if direction in ['east', 'north', 'west', 'south']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['east', 'north', 'west', 'south'].")

        super(Muscle, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

    def __str__(self):
        return 'littlefish.brain.Muscle object'

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the muscle will try to move the fish or not
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: no attempt: False
                 attempt: movement vector, tuple of two ints
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise (ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                if self._direction == 'east':
                    return 0, 1
                elif self._direction == 'north':
                    return -1, 0
                elif self._direction == 'west':
                    return 0, -1
                elif self._direction == 'south':
                    return 1, 0
                else:
                    raise(ValueError, "self.direction should be one of the following: "
                                      "['east', 'north', 'west', 'south'].")
            else:
                return False

    def to_h5_group(self, h5_group):

        h5_group.attrs['baseline_rate_action_per_tu'] = self._baseline_rate
        h5_group.attrs['refractory_period_tu'] = self._refractory_period
        h5_group.attrs['neuron_type'] = 'muscle'
        h5_group.attrs['direction'] = self._direction
        h5_group.create_dataset('action_history_tu', data=self._action_history)


class Connection(object):
    """
    synaptic connection between two neurons
    """

    def __init__(self, latency=CONNECTION_LATENCY, amplitude=CONNECTION_AMPLITUDE, rise_time=CONNECTION_RISE_TIME,
                 decay_time=CONNECTION_DECAY_TIME):
        """

        :param latency: int, temporal latency from presynaptic neuron action to the postsynaptic effect onset, number
                        of time units
        :param amplitude: float, peak change of the firing rate in the postsynaptic neuron, probablity of a action per
                          time unit. can be positive (excitatiory) or negative (inhibitory)
        :param rise_time: int, temporal duration from onset to peak, number of time units
        :param decay_time: int, temporal duration from peak to baseline, number of time units
        """

        if latency is not None:
            if not isinstance(latency, int):
                raise (ValueError, 'latency should be an integer.')
            self._latency = latency

        if amplitude is not None:
            self._amplitude = float(amplitude)

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise (ValueError, 'rise_time should be an integer.')
            self._rise_time = rise_time

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise (ValueError, 'decay_time should be an integer.')
            self._decay_time = decay_time

        self._generate_psp()

    def __str__(self):
        return 'littlefish.brain.Connection object'

    def get_latency(self):
        return self._latency

    def get_amplitude(self):
        return self._amplitude

    def get_rise_time(self):
        return self._rise_time

    def get_decay_time(self):
        return self._decay_time

    def _generate_psp(self):
        """
        generate post synaptic probability wave form
        """

        self._psp = np.zeros(self._latency + self._rise_time + self._decay_time)
        self._psp[self._latency: self._latency + self._rise_time] = self._amplitude * \
            (np.arange(self._rise_time) + 1).astype(np.float32) / float(self._rise_time)
        self._psp[-self._decay_time:] = self._amplitude * \
            (np.arange(self._decay_time, 0, -1) - 1).astype(np.float32) / float(self._decay_time)

    def get_psp(self):
        return self._psp

    def set_params(self, latency=None, amplitude=None, rise_time=None, decay_time=None):
        """
        set new parameters and regenerate psp waveform

        :param latency: int, number of time units for time delay
        :param amplitude: float, peak probability
        :param rise_time: int, number of time units to rise to peak
        :param decay_time: int, number of time units to decay to baseline
        """

        changed = False

        if latency is not None:
            if not isinstance(latency, int):
                raise (ValueError, 'latency should be an integer.')
            self._latency = latency
            changed = True

        if amplitude is not None:
            self._amplitude = float(amplitude)
            changed = True

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise (ValueError, 'rise_time should be an integer.')
            self._rise_time = rise_time
            changed = True

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise (ValueError, 'decay_time should be an integer.')
            self._decay_time = decay_time
            changed = True

        if changed:
            self._generate_psp()
        else:
            print('Brain.Connection: no parameter has been changed. Do nothing.')

    def act(self, t_point, postsynaptic_input):
        """
        if the presynaptic neuron fires at the 'time_point', a psp wave form will be generated and add to the
        input array of the postsynaptic neuron
        :param t_point: int, current time point as the index of time unit axis
        :param postsynaptic_input: 1-d array of floats
        :return:
        """
        psp_end = t_point + len(self._psp)
        if psp_end <= len(postsynaptic_input):
            postsynaptic_input[t_point: psp_end] += self._psp
        else:
            postsynaptic_input[t_point:] += self._psp[:len(postsynaptic_input) - t_point]


class Brain(object):
    """
    brain class, the neural network from eye to muscle

    a 'brain' has a couple of sets of 8 eyes (brain.Eye object, each at each border pixel of the body). each set of
    eyes are receiving inputs from different objects. i.e. one set of eyes will look at land/water, another set of eyes
    will look for food, another set of eyes will look for other fish.

    a 'brain' has 4 invisible muscles (brain.Muscle object, each controlling the movement in each direction).

    between eyes and muscles are a neural network consists of neurons (brain.Neuron object) and connections
    (brain.Connections object). Number of layers and number of neurons can be specified.
    """

    def __init__(self, neurons=None, connections=None):
        """

        :param neurons:
        :param connections:
        """

        if neurons is None:
            self._generate_default_neurons()
        else:
            self._neurons = neurons

        if connections is None:
            self._generate_default_connections()
        else:
            self._connections = connections

        self._generate_connection_map()

        self._psp_waveforms = None

        self.check_integrity()

    def __str__(self):
        return 'littlefish.brain.Brain object'

    def _generate_default_neurons(self):
        """
        generate and return a dataframe containing all neurons with default parameters
        """
        neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'neuron'])

        ind = 0
        for i in range(8):
            curr_dir, curr_type = self.get_eye_type(i)
            neurons.loc[ind] = [0, i, Eye2(direction=curr_dir, input_filter=EYE2_INPUT_FILTER, gain=EYE_GAIN,
                                           input_type=curr_type, baseline_rate=EYE_BASELINE_RATE,
                                           refractory_period=EYE_REFRACTORY_PERIOD)]
            ind += 1

        for i in range(8):
            neurons.loc[ind] = [1, i, Neuron(baseline_rate=NEURON_BASELINE_RATE,
                                             refractory_period=NEURON_REFRACTORY_PERIOD)]
            ind += 1

        for i in range(4):
            curr_dir = self.get_muscle_direction(i)
            neurons.loc[ind] = [2, i, Muscle(direction=curr_dir, baseline_rate=MUSCLE_BASELINE_RATE,
                                             refractory_period=MUSCLE_REFRACTORY_PERIOD)]
            ind += 1

        neurons['layer'] = neurons['layer'].astype(np.uint32)
        neurons['neuron_ind'] = neurons['neuron_ind'].astype(np.uint32)

        self._neurons = neurons
        print('\nBrain: a dataframe with 20 default neurons and 3 layers (eye, hidden, muscle) has been generated.')

    def _generate_default_connections(self):
        """
        generate all possible connections among self_neurons with default parameters
        """

        connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'connection'])

        ind = 0

        for pre_layer in range(self.layer_num - 1):
            post_layer = pre_layer + 1
            post_neuron_inds = self.get_neuron_inds_in_layer(post_layer)
            pre_neuron_inds = self.get_neuron_inds_in_layer(pre_layer)

            for pre_neuron_ind in pre_neuron_inds:
                for post_neuron_ind in post_neuron_inds:
                    connections.loc[ind] = [pre_neuron_ind, post_neuron_ind,
                                            Connection(latency=CONNECTION_LATENCY, amplitude=CONNECTION_LATENCY,
                                                       rise_time=CONNECTION_RISE_TIME,
                                                       decay_time=CONNECTION_DECAY_TIME)]
                    ind += 1

        self._connections = connections
        print('\nBrain: a dataframe of default ' + str(len(self._connections)) +
              ' connections among self._neurons has been generated')

    def get_neurons(self):
        return self._neurons

    @property
    def layer_num(self):
        return int(round(max(self._neurons['layer']))) + 1

    def get_layer_type(self, layer):
        """
        return layer type (str) given the layer number
        """
        if not isinstance(layer, int):
            raise (ValueError, 'Input layer number should be integer.')

        if layer == 0:
            return 'eye'
        elif layer == self.layer_num - 1:
            return 'muscle'
        elif layer > 0 and layer < self.layer_num - 1:
            return 'hidden' + util.int2str(layer, 3)
        else:
            raise (ValueError, 'layer number out of range.')

    def get_neuron_type(self, ind):
        """
        return neuron type as a pair of strings given the index in self._neurons
        :param ind: int
        :return: for eyes : ('eye', type + short of direction)
                 for hidden neurons: ('hidden', str(layer))
                 for muscles ('muscle', short of direction)
        """

        self.check_integrity_neurons()

        curr_row = self._neurons.loc[ind]
        curr_layer = curr_row['layer']
        if curr_layer == 0:  # eye layer
            curr_dir, curr_type = self.get_eye_type(curr_row['neuron_ind'])
            return util.short('eye') + '_' + util.short(curr_type) + '_' + util.short(curr_dir)
        elif curr_layer == self.layer_num - 1:  # muscle layer
            curr_dir = MUSCLE_DIRECTIONS[curr_row['neuron_ind'] % len(MUSCLE_DIRECTIONS)]
            return util.short('muscle') + '_' + util.short(curr_dir)
        elif curr_layer > 0 and curr_layer < self.layer_num - 1:
            curr_layer_num = util.int2str(curr_layer, 3)
            curr_neuron_num = util.int2str(curr_row['neuron_ind'], 3)
            return '_'.join([util.short('hidden'), curr_layer_num, curr_neuron_num])
        else:
            raise (ValueError, 'layer number out of range.')

    def get_connections(self):
        return self._connections

    def get_postsynaptic_neuron_ind(self, neuron_ind):

        neuron_layer = int(round(self._neurons.loc[neuron_ind, 'layer']))
        if neuron_layer < 0:
            raise(ValueError, 'Brain: invalid layer. less than 0.')
        elif neuron_layer == self.layer_num - 1:
            print('Brain: cannot fine postsynaptic neuron of neurons in muscle layer.')
        else:
            postsynaptic_neuron_ind = self._neurons[self._neurons['layer'] == neuron_layer + 1].index.tolist()
            postsynaptic_neuron_ind.sort()
            return postsynaptic_neuron_ind

    def get_presynaptic_neuron_ind(self, neuron_ind):

        neuron_layer = int(round(self._neurons.loc[neuron_ind, 'layer']))
        if neuron_layer < 0:
            raise(ValueError, 'Brain: invalid layer. less than 0.')
        elif neuron_layer == 0:
            print('Brain: cannot fine presynaptic neuron of neurons in eye layer.')
        else:
            presynaptic_neuron_ind = self._neurons[self._neurons['layer'] == neuron_layer - 1].index.tolist()
            presynaptic_neuron_ind.sort()
            return presynaptic_neuron_ind

    def get_single_connection(self, pre_neuron_ind, post_neuron_ind):

        connection = self._connections[(self._connections['presynaptic_ind'] == pre_neuron_ind) & \
                                       (self._connections['postsynaptic_ind'] == post_neuron_ind)]
        if len(connection) == 1:
            return connection.iloc[0, 2]
        elif len(connection) == 0:
            print('Brain: cannot find a connection between neuron ' + str(pre_neuron_ind) +' and neuron ' + \
                  str(post_neuron_ind))
        else:
            raise(ValueError,'Brain: found more than one connection between neuron ' + str(pre_neuron_ind) +
                             ' and neuron ' + str(post_neuron_ind))

    def get_neuron_inds_in_layer(self, layer):
        """
        return a list of sorted neuron_indices of all neurons in a given layer
        """
        inds = self._neurons[self._neurons['layer'] == layer].index.tolist()
        inds.sort()
        return inds

    def has_action_histories(self):
        for neuron in self._neurons['neuron']:
            if len(neuron.get_action_history()) > 0:
                return True
        return False

    def has_psp_waveforms(self):
        if self._psp_waveforms is not None:
            return True
        else:
            return False

    def has_connection_map(self):
        if not hasattr(self, '_connection_map'):
            return False
        elif self._connection_map is None:
            return False
        else:
            return True

    def generate_empty_psp_waveforms(self):
        if self.has_psp_waveforms():
            raise (ValueError, 'Brain: can not generate empty psp waveforms, psp waveforms already exist.')

        self._psp_waveforms = {}

        waveform_count = 0
        for i in range(len(self._neurons)):
            if self._neurons.loc[i, 'layer'] > 0:
                self._psp_waveforms.update({i: np.zeros(SIMULATION_LENGTH, dtype=np.float32)})

        print('\nBrain: empty psp waveforms created. number of waveforms: ' + str(len(self._psp_waveforms)) + \
              '; length of waveforms: ' + str(SIMULATION_LENGTH) + ' time units.')

    def _generate_connection_map(self):
        """
        map from presynaptic neuron index to (connection index, postsynaptic neuron index) pair

        :return dictionary,
        {presynaptic neuron ind in self._neurons: a list of tuple (connection index,
                                                                   postsynaptic neuron index in self._neurons)}

         this dictionary will be stalled as self._connection_map

         the information in self._connection_map is redundant given self._neurons and self._connections.
         But with this generated once and installed in memory, the simulation can be much faster (hopefully)
        """
        self._connection_map = {}

        presynaptic_indices = np.unique(self._connections.loc[:, 'presynaptic_ind'])

        for presynaptic_ind in presynaptic_indices:
            postsynaptic_pairs = []
            for j in range(len(self._connections)):
                if self._connections.loc[j, 'presynaptic_ind'] == presynaptic_ind:
                    postsynaptic_pairs.append((j, self._connections.loc[j, 'postsynaptic_ind']))
            self._connection_map.update({presynaptic_ind: postsynaptic_pairs})

        print('\nBrain: connection map generated.')
        # print self._connection_map

    def check_integrity(self):
        """
        check integrity of object data structure
        """

        print('\nBrain: checking integrity of attrbitue data structure ...')

        self.check_integrity_neurons(verbose=True)

        if not util.check_df_index(self._connections):
            raise(ValueError, 'Brain: the indices of self._connections are not starting at 0 and increasing with '
                              'step 1.')
        else:
            print('Brain: the indices of self._connections are starting at 0 and increasing with step 1. PASS.')

        for i, connection in self._connections.iterrows():
            if self._neurons.loc[connection['presynaptic_ind'], 'layer'] + 1 != \
                    self._neurons.loc[connection['postsynaptic_ind'], 'layer']:
                raise(ValueError, 'Brain: the ' + str(i) + 'th connection in self._connections does not represent a '
                                                           'true pre-post synaptic connection')
        print('Brain: all connections in self._connections represent true pre-post synaptic connection. PASS')

        presynaptic_ind = 0
        for i, connection in self._connections.iterrows():
            curr_presynaptic_ind = connection['presynaptic_ind']
            if curr_presynaptic_ind == presynaptic_ind:
                pass
            elif curr_presynaptic_ind == presynaptic_ind + 1:
                presynaptic_ind = curr_presynaptic_ind
            else:
                raise(ValueError, 'Brain: "presynaptic_ind" of self._connections is not non-descending from 0 by '
                                  'step 1.')
        print('Brain: "presynaptic_ind" of self._connections is non-descending from 0 by step 1. PASS')

        connection_map_keys = self._connection_map.keys()
        connection_map_keys.sort()
        if not np.array_equal(connection_map_keys, self.get_all_presynaptic_neuron_indices()):
            raise(ValueError, 'Brain: keys in self._connection_map do not represent all presynaptic neurons in '
                              'self._neurons.')
        else:
            print('Brain: keys in self._connection_map do not represent all presynaptic neurons in '
                  'self._neurons. PASS')

        for pre, value in self._connection_map.items():
            conn = [v[0] for v in value]
            post = [v[1] for v in value]
            post.sort()
            pre_layer = self._neurons.loc[pre, 'layer']
            if not np.array_equal(post, self.get_neuron_indices(pre_layer + 1)):
                raise(ValueError, 'Brain: the values in self._connection_map do not represent all postsynaptic neurons '
                                  'of the presynaptic neuron.')
            for i, conn_ind in enumerate(conn):
                if self._connections.loc[conn_ind, 'presynaptic_ind'] != pre or \
                        self._connections.loc[conn_ind, 'postsynaptic_ind'] != post[i]:
                    raise(ValueError, 'Brain: the values in self._connection_map do not match intended '
                                      'pre-post synaptic connections.')
        print('Brain: the values in self._connection_map represent all postsynaptic neurons of the presynaptic '
              'neuron. PASS')
        print('Brain: the values in self._connection_map match intended pre-post synaptic connections. PASS')

        if not self.has_psp_waveforms():
            print('Brain: self._psp_waveforms is None. Please use self.generate_empty_psp_waveforms() to generate psp '
                  'waveforms before simulation.')
        else:
            psp_waveform_keys = self._psp_waveforms.keys()
            psp_waveform_keys.sort()
            if not np.array_equal(psp_waveform_keys, self.get_all_postsynaptic_neuron_indices()):
                raise(ValueError, 'Brain: the keys of self._psp_waveforms do not represent all postsynaptic neurons '
                                  'in self._neurons.')
            else:
                print('Brain: the keys of self._psp_waveforms do represent all postsynaptic neurons in '
                      'self._neurons. PASS')

        print('Brain: integrity checking finished. All pass.\n')

    def check_integrity_neurons(self, verbose=False):

        if not util.check_df_index(self._neurons):
            raise(ValueError, 'Brain: the indices of self._neurons are not starting at 0 and increasing with step 1.')
        else:
            if verbose:
                print('Brain: the indices of self._neurons are starting at 0 and increasing with step 1. PASS.')
            else:
                pass

        layer = 0
        ind = -1
        for i, neuron in self._neurons.iterrows():
            curr_layer = int(round(neuron['layer']))
            curr_neuron_ind = neuron['neuron_ind']
            if curr_layer < layer:
                raise(ValueError, 'Brain: the "layer" in self._neurons is not in ascending order.')
            elif curr_layer == layer:
                if curr_neuron_ind != ind + 1:
                    raise(ValueError, 'Brain: the "neuron_ind" in self._neurons is not in ascending by step 1 for each '
                                      '"layer"')
                else:
                    ind += 1
            else:
                layer = curr_layer
                if curr_neuron_ind != 0:
                    raise(ValueError, 'Brain: the "neuron_ind" in self._neurons does not start with 0 for each "layer".')
                ind = 0

            if curr_layer == 0:  # eye layer
                if not (str(neuron['neuron']) == 'littlefish.brain.Eye object' or \
                        str(neuron['neuron']) == 'littlefish.brain.Eye2 object'):
                    raise(ValueError, 'Brain: non-eye object in eye layer.')
            elif curr_layer == self.layer_num - 1:  # muscle layer
                if not str(neuron['neuron']) == 'littlefish.brain.Muscle object':
                    raise(ValueError, 'Brain: non-muscle object in muscle layer.')
            else:  # hidden layer
                if not str(neuron['neuron']) == 'littlefish.brain.Neuron object':
                    raise(ValueError, 'Brain: non-neuron object in hidden layer.')

        if verbose:
            print('Brain: the "layer" of self._neurons is in a non-descending order. PASS')
            print('Brain: the "neuron_ind" of self._neurons for each layer is ascending from 0 by step 1. PASS')
            print('Brain: eyes in eye layer, muscles in muscle layer, neurons in hidden layer. PASS')

    def act(self, t_point, body_position, terrain_map, food_map=None, fish_map=None):
        """
        :param t_point: int, current time stamp of time unit axis
        :param body_position: tuple of two ints, (row, col), current position of body center of the fish
        :param terrain_map: 2d array, with only 0s (water) and 1s (land). represents the land scape of the world
        :param food_map: 2d array, with only 0s (no food) and 1s (food). represents the distribution of food
        :return: movement attemps: tuple of 2 ints, represting the movement attempt, be careful, this may not
                                   represent the actual movement, it will be evaluated by the fish object (fish class)
                                   containing this brain to see if the movement is possible. if the fish is hitting
                                   the edge the world map, then the it will not move out of the map
                                   None: no movement has been attempted,
        """
        if len(body_position) != 2:
            raise (ValueError, 'body_position should contain two elements.')

        if (not isinstance(body_position[0], int)) or (not isinstance(body_position[1], int)):
            raise (ValueError, 'body_position should contain two integers.')

        if len(terrain_map.shape) != 2:
            raise(ValueError, 'terrain_map should be a 2-d array.')

        if not np.issubdtype(terrain_map.dtype, np.integer):
            raise(ValueError, 'dtype of terrain_map should be integer.')

        if np.max(terrain_map) > 1 or np.min(terrain_map) < 0:
            raise(ValueError, 'terrain_map should only contain 0s and 1s.')

        if body_position[0] < 1 or body_position[0] > terrain_map.shape[0] - 2 or \
            body_position[1] < 1 or body_position[1] > terrain_map.shape[1] - 2:
            raise(ValueError, 'body_position out of the range.')

        if not self.has_psp_waveforms():
            self.generate_empty_psp_waveforms()

        movement_attempt = [0, 0]

        for i, neuron in self._neurons.iterrows():

            if neuron['layer'] == 0:  # eye layer
                curr_eye = neuron['neuron']
                curr_eye_pos = curr_eye.get_position(body_position=body_position)

                if curr_eye.get_input_type() == 'terrain':
                    is_fire = curr_eye.act(t_point=t_point, position=curr_eye_pos, input_map=terrain_map)
                elif curr_eye.get_input_type() == 'food':
                    if food_map is not None:
                        is_fire = curr_eye.act(t_point=t_point, position=curr_eye_pos, input_map=food_map)
                    else:
                        is_fire = False
                elif curr_eye.get_input_type() == 'fish':
                    if fish_map is not None:
                        is_fire = curr_eye.act(t_point=t_point, position=curr_eye_pos, input_map=fish_map)
                    else:
                        is_fire = False
                else:
                    raise(ValueError, 'Brain: the input_type of eye should be one of the following:'
                                      '"terrain", "food" or "fish".')

                if is_fire:  # the current eye fires
                    # print('eye spike')
                    self.neuron_fire(neuron_ind=i, t_point=t_point)

            elif neuron['layer'] < self.layer_num - 1:  # hidden layer
                curr_neuron = neuron['neuron']
                is_fire = curr_neuron.act(t_point=t_point, probability_input=self._psp_waveforms[i][t_point])
                if is_fire:
                    # print('neuron spike')
                    self.neuron_fire(neuron_ind=i, t_point=t_point)

            elif neuron['layer'] == self.layer_num - 1:  # muscle layer
                curr_muscle = neuron['neuron']
                curr_movement_attempt = curr_muscle.act(t_point=t_point, probability_input=self._psp_waveforms[i][t_point])
                if curr_movement_attempt:
                    # print('muscle spike')
                    movement_attempt[0] += curr_movement_attempt[0]
                    movement_attempt[1] += curr_movement_attempt[1]

            else:
                raise(ValueError, 'Brain: neuron at index' + str(i) + ' has invalid layer location.')

        return movement_attempt

    def neuron_fire(self, neuron_ind, t_point):
        """
        updata all corresponding psp waveforms when a presynaptic neuron (only in eye layer and hidden layer) fires
        :param neuron_ind: int, the index of presynaptic neuron in self._neurons
        :param t_point: int, time point in time unit axis of the action
        :return: None
        """
        if not self.has_psp_waveforms:
            raise(ValueError, 'Brain: cannot find self._psp_waveforms, please generate them first.')

        if not self.has_connection_map():
            raise(ValueError, 'Brain: cannot find self._connection_map, please generate it first.')

        neuron_layer = int(round(self._neurons.loc[neuron_ind, 'layer']))

        if neuron_layer >= 0 and neuron_layer < self.layer_num -1:  # eye layer or hidden layer
            for postsynaptic_component in self._connection_map[neuron_ind]:
                curr_connection = self._connections.loc[postsynaptic_component[0], 'connection']
                curr_psp_waveform = self._psp_waveforms[postsynaptic_component[1]]
                curr_connection.act(t_point=t_point, postsynaptic_input=curr_psp_waveform)
        elif neuron_layer == self.layer_num -1:  # muscle layer
            print('Brain: a firing of a muscle has no effect on brain itself. Please use Muscle.act() method to '
                  'generate movement attempt.')
        else:
            raise(ValueError, 'Brain: neuron at index' + str(neuron_ind) + ' has invalid layer location.')

    def get_neuron_indices(self, layer):
        """
        get indices of all neurons in a specific layer
        """
        ind = self._neurons[self._neurons['layer'] == layer].index
        return ind.sort_values()

    def get_all_presynaptic_neuron_indices(self):
        """
        get indices of all presynaptic neurons
        """
        layer_num = int(max(self._neurons['layer'])) + 1
        ind = self._neurons[self._neurons['layer'] < layer_num -1].index
        return ind.sort_values()

    def get_all_postsynaptic_neuron_indices(self):
        """
        get indices of all postsynaptic neurons
        """
        ind = self._neurons[self._neurons['layer'] > 0].index
        return ind.sort_values()

    def _clear_psp_waveforms(self):
        if self.has_psp_waveforms():
            self._psp_waveforms = None
            print('Brain: all psp waveforms deleted.')
        else:
            print('Brain: no psp waveforms found. Do nothing.')

    def _clear_action_histories(self):
        if self.has_action_histories():
            for neuron in self._neurons['neuron']:
                neuron.reset_action_history([])
            print('Brain: action histories of all neurons have been deleted.')
        else:
            print('Brain: no action history is found for any neuron. Do nothing.')

    def clear_simulation_data(self):
        self._clear_psp_waveforms()
        self._clear_action_histories()

    def plot_action_histories_scatter(self, plot_length, plot_axis=None, is_separated=True, **kwargs):
        """
        plot action histories of all neurons as scatter plot, eye spikes: red, hidden layer spikes: green,
        muscle spikes: blue
        :param plot_length: int, total length of plot, number of time units
        :param is_separated: bool, plot separation line or not
        :param plot_axis: matplotlib.pyplot.axis object
        :param kwargs: other inputs to matplotlib.pyplot.plot function
        :return:
        """

        if not self.has_action_histories():
            raise(LookupError, 'Brain: No action history found. Cannot plot.')

        self.check_integrity_neurons()

        if plot_axis is None:
            f = plt.figure(figsize=(15, 10))
            plot_axis = f.add_subplot(111)

        if plot_length is None:
            plot_length = SIMULATION_LENGTH

        total_neuron_num = len(self._neurons)
        total_y = range(total_neuron_num)

        if is_separated:
            total_separation = [y + 0.5 for y in total_y]
            for separation in total_separation:
                plot_axis.plot([0, plot_length], [separation, separation], '--', color='#888888')

        yticklaybels = []

        for i, neuron_df in self._neurons.iterrows():
            curr_layer_type = self.get_layer_type(int(neuron_df['layer']))
            curr_action_history = neuron_df['neuron'].get_action_history()
            curr_y = total_y[i]

            if 'eye' in curr_layer_type:
                util.plot_spike_ticks(curr_action_history, y=curr_y, plot_axis=plot_axis, color='r', **kwargs)
            elif 'hidden' in curr_layer_type:
                util.plot_spike_ticks(curr_action_history, y=curr_y, plot_axis=plot_axis, color='g', **kwargs)
            elif 'muscle' in curr_layer_type:
                util.plot_spike_ticks(curr_action_history, y=curr_y, plot_axis=plot_axis, color='b', **kwargs)

            yticklaybels.append(self.get_neuron_type(i))

        plot_axis.set_xlim([0, plot_length])
        plot_axis.set_ylim([-0.5, total_neuron_num - 0.5])
        plot_axis.invert_yaxis()
        plot_axis.set_xlabel('time (time unit)')
        plot_axis.set_ylabel('neuron index')
        plot_axis.set_yticks(total_y)
        plot_axis.set_yticklabels(yticklaybels, family='monospace')

    def get_connection_matrices(self, pre_layer, post_layer):
        """
        return several numpy arrays each represent one parameter of all connections between a presynaptic layer and
        a postsynaptic layer, each row is a postsynaptic neuron, each column is a presynaptic neuron

                       pre neuron 0,  pre neuron 1,  pre neuron 2,  ... ,  pre neuron m
        post neuron 0
        post neuron 1
        post neuron 2
        ...
        post neuron n

        :param pre_layer: int, layer number of presynaptic layer
        :param post_layer: int, layer number of postsynaptic layer
        :return: rows, list of ints, postsynaptic neuron inds for each row
                 cols, list of ints, presynaptic neuron inds for each column
                 latencies, amplitudes, rise_times, decay_times: matrices for each connection parameter as described
                 above
        """

        rows = self.get_neuron_inds_in_layer(post_layer)
        cols = self.get_neuron_inds_in_layer(pre_layer)

        latencies = np.empty((len(rows), len(cols)), dtype=np.int)
        amplitudes = np.empty((len(rows), len(cols)), dtype=np.float)
        rise_times = np.empty((len(rows), len(cols)), dtype=np.int)
        decay_times = np.empty((len(rows), len(cols)), dtype=np.int)

        for i, pre_ind in enumerate(cols):
            for j, post_ind in enumerate(rows):
                curr_conn = self.get_single_connection(pre_ind, post_ind)
                latencies[j, i] = curr_conn.get_latency()
                amplitudes[j, i] = curr_conn.get_amplitude()
                rise_times[j, i] = curr_conn.get_rise_time()
                decay_times[j, i] = curr_conn.get_decay_time()
        return rows, cols, latencies, amplitudes, rise_times, decay_times

    def to_h5_group(self, h5_group):

        neuron_group = h5_group.create_group('neurons')
        for i, neuron_df in self._neurons.iterrows():
            neuron_name = 'neuron_' + util.int2str(i, 5)
            curr_neuron_group = neuron_group.create_group(neuron_name)
            neuron_df['neuron'].to_h5_group(curr_neuron_group)
            curr_neuron_group.attrs['ind'] = i
            curr_neuron_group.attrs['layer'] = neuron_df['layer']
            curr_neuron_group.attrs['neuron_ind'] = neuron_df['neuron_ind']

        connection_group = h5_group.create_group('connections')
        for pre_layer in range(self.layer_num-1):
            post_layer =  pre_layer + 1
            curr_connection_matrices = self.get_connection_matrices(pre_layer=pre_layer, post_layer=post_layer)

            curr_layer_group = connection_group.create_group('L' + util.int2str(pre_layer, 3) +
                                                             '_L' + util.int2str(post_layer, 3))
            curr_layer_group.attrs['rows'] = curr_connection_matrices[0]
            curr_layer_group.attrs['cols'] = curr_connection_matrices[1]
            curr_layer_group.attrs['doc'] = 'rows: indices of postsynatpic neurons in the neuron group; ' \
                                            'cols: indices of presynaptic neurons in the neuron group.'
            curr_layer_group.create_dataset(name='latencies_au', data=curr_connection_matrices[2])
            curr_layer_group.create_dataset(name='amplitudes', data=curr_connection_matrices[3])
            curr_layer_group.create_dataset(name='rise_times_au', data=curr_connection_matrices[4])
            curr_layer_group.create_dataset(name='decay_times_au', data=curr_connection_matrices[5])

    @staticmethod
    def get_eye_type(ind):
        """
        given the neuron_ind in the eye layer return direction and input type of a specific eye
        :return: two strings, (direction, type)
        """
        direction_num = len(EYE_DIRECTIONS)
        return EYE_DIRECTIONS[ind % direction_num], EYE_INPUT_TYPES[ind // direction_num]

    @staticmethod
    def get_muscle_direction(ind):
        """
        given the neuron_ind in the muscle layer return direction of a specific muscle
        :return: string, direction of the muscle
        """
        direction_num = len(MUSCLE_DIRECTIONS)
        return MUSCLE_DIRECTIONS[ind % direction_num]

    @staticmethod
    def from_h5_group(h5_group):

        neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'neuron'])

        neurons_group = h5_group['neurons']
        neuron_names = neurons_group.keys()
        neuron_names.sort()
        for neuron_name in neuron_names:
            curr_neuron_group = neurons_group[neuron_name]


        connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'connection'])

        # todo: finishe this method
        pass
    
    # @staticmethod
    # def generate_default_neurons_df():
    #     """
    #     generate and return a dataframe containing all neurons with default parameters
    #     """
    #     neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'baseline_rate', 'refractory_period'])
    #
    #     ind = 0
    #     for i in range(8):
    #         neurons.loc[ind] = [0, i, EYE_BASELINE_RATE, EYE_REFRACTORY_PERIOD]
    #         ind += 1
    #
    #     for i in range(8):
    #         neurons.loc[ind] = [1, i, NEURON_BASELINE_RATE, NEURON_REFRACTORY_PERIOD]
    #         ind += 1
    #
    #     for i in range(4):
    #         neurons.loc[ind] = [2, i, MUSCLE_BASELINE_RATE, MUSCLE_REFRACTORY_PERIOD]
    #         ind += 1
    #
    #     neurons['layer'] = neurons['layer'].astype(np.uint32)
    #     neurons['neuron_ind'] = neurons['neuron_ind'].astype(np.uint32)
    #     neurons['baseline_rate'] = neurons['baseline_rate'].astype(np.float64)
    #     neurons['refractory_period'] = neurons['refractory_period'].astype(np.uint64)
    #
    #     return neurons
    #
    # @staticmethod
    # def generate_default_connections_df(neurons_df):
    #     """
    #     from a dataframe containing parameters of all neurons, generate and return a dataframe containing all
    #     connections with default parameters
    #     """
    #     layer_num = np.max(neurons_df['layer']) + 1
    #
    #     connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'latency', 'amplitude',
    #                                         'rise_time', 'decay_time'])
    #
    #     ind = 0
    #     for i in range(len(neurons_df)):
    #         curr_presynaptic_layer = neurons_df.loc[i,'layer']
    #         if curr_presynaptic_layer < layer_num - 1:
    #             for j in range(len(neurons_df)):
    #                 if neurons_df.loc[j, 'layer'] == curr_presynaptic_layer + 1:
    #                     connections.loc[ind] = [i, j, CONNECTION_LATENCY, CONNECTION_AMPLITUDE, CONNECTION_RISE_TIME,
    #                                             CONNECTION_DECAY_TIME]
    #                     ind += 1
    #
    #     connections['presynaptic_ind'] = connections['presynaptic_ind'].astype(np.uint32)
    #     connections['postsynaptic_ind'] = connections['postsynaptic_ind'].astype(np.uint32)
    #
    #     return connections
    #
    # def _generate_neurons(self, neurons_df, verbose_level=1):
    #     """
    #     generate a dataframe containing actual Neuron objects from a dataframe containing neuron parameters.
    #     assign it to self._neurons
    #     """
    #
    #     self._neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'neuron'])
    #
    #     layer_num = int(round(max(neurons_df['layer']))) + 1
    #
    #     params = neurons_df.columns.values.tolist()
    #
    #     for i, row in neurons_df.iterrows():
    #
    #         if int(row['layer']) == 0:  #  eye layer
    #
    #             curr_ind = int(row['neuron_ind'])
    #             curr_dir, curr_type = self.get_eye_type(curr_ind)
    #
    #             if 'eye2_input_filter' not in params:
    #                 eye2_input_filter = EYE2_INPUT_FILTER
    #             else:
    #                 eye2_input_filter = row['eye_input_filter']
    #
    #             if 'eye_gain' not in params:
    #                 eye_gain = EYE_GAIN
    #             else:
    #                 eye_gain = float(row['eye_gain'])
    #
    #             if 'baseline_rate' not in params:
    #                 eye_baseline_rate = EYE_BASELINE_RATE
    #             else:
    #                 eye_baseline_rate = float(row['baseline_rate'])
    #
    #             if 'refractory_period' not in params:
    #                 eye_refractory_period = EYE_REFRACTORY_PERIOD
    #             else:
    #                 eye_refractory_period = int(row['refractory_period'])
    #
    #             self._neurons.loc[i] = \
    #                 [row['layer'],
    #                  row['neuron_ind'],
    #                  Eye2(direction=curr_dir,
    #                       input_filter=eye2_input_filter,
    #                       gain=eye_gain,
    #                       input_type=curr_type,
    #                       baseline_rate=eye_baseline_rate,
    #                       refractory_period=eye_refractory_period)]
    #
    #             # print(row['layer'], 'eye')
    #
    #         elif int(row['layer']) == layer_num - 1:  #  muscle layer
    #
    #             curr_ind = int(row['neuron_ind'])
    #             curr_dir = self.get_muscle_direction(curr_ind)
    #
    #             if 'baseline_rate' not in params:
    #                 muscle_baseline_rate = MUSCLE_BASELINE_RATE
    #             else:
    #                 muscle_baseline_rate = row['baseline_rate']
    #
    #             if 'refractory_period' not in params:
    #                 muscle_refractory_period = MUSCLE_REFRACTORY_PERIOD
    #             else:
    #                 muscle_refractory_period = row['refractory_period']
    #
    #             self._neurons.loc[i] = \
    #                 [row['layer'],
    #                  row['neuron_ind'],
    #                  Muscle(direction=curr_dir,
    #                         baseline_rate=muscle_baseline_rate,
    #                         refractory_period=muscle_refractory_period)]
    #
    #             # print(row['layer'], 'muscle')
    #
    #         else:  # hidden layer
    #             if 'baseline_rate' not in params:
    #                 neuron_baseline_rate = NEURON_BASELINE_RATE
    #             else:
    #                 neuron_baseline_rate = row['baseline_rate']
    #
    #             if 'refractory_period' not in params:
    #                 neuron_refractory_period = NEURON_REFRACTORY_PERIOD
    #             else:
    #                 neuron_refractory_period = row['refractory_period']
    #
    #             self._neurons.loc[i] = \
    #                 [row['layer'],
    #                  row['neuron_ind'],
    #                  Neuron(baseline_rate=neuron_baseline_rate,
    #                         refractory_period=neuron_refractory_period)]
    #
    #             # print(row['layer'], 'neuron')
    #
    #     self._neurons['layer'] = self._neurons['layer'].astype(np.uint32)
    #     self._neurons['neuron_ind'] = self._neurons['neuron_ind'].astype(np.uint32)
    #
    #     if verbose_level == 0:
    #         print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.\n')
    #     elif verbose_level == 1:
    #         print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.')
    #         layer_num = max(self._neurons['layer']) + 1
    #         for layer in range(layer_num):
    #             layer_name = self.get_layer_type(layer)
    #             neuron_num = len(self._neurons[self._neurons.layer == layer])
    #             print(layer_name + ' layer: ' + str(neuron_num) + ' neurons.')
    #     elif verbose_level == 2:
    #         print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.')
    #         print(self._neurons)
    #
    # def _generate_connections(self, connections_df, verbose_level=0):
    #     """
    #     generate a dataframe containing actual Connection objects from a dataframe containing connection parameters.
    #     assign it to self._connections
    #     """
    #     self._connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'connection'])
    #     for i, row in connections_df.iterrows():
    #
    #         if 'latency' not in connections_df.columns.values.tolist():
    #             latency = CONNECTION_LATENCY
    #         else:
    #             latency = int(row.latency)
    #
    #         if 'amplitude' not in connections_df.columns.values.tolist():
    #             amplitude = CONNECTION_AMPLITUDE
    #         else:
    #             amplitude = float(row.amplitude)
    #
    #         if 'rise_time' not in connections_df.columns.values.tolist():
    #             rise_time = CONNECTION_RISE_TIME
    #         else:
    #             rise_time = int(row.rise_time)
    #
    #         if 'decay_time' not in connections_df.columns.values.tolist():
    #             decay_time = CONNECTION_DECAY_TIME
    #         else:
    #             decay_time = int(row.decay_time)
    #
    #         self._connections.loc[i] = [row.presynaptic_ind, row.postsynaptic_ind,
    #                                     Connection(latency, amplitude, rise_time, decay_time)]
    #
    #     self._connections['presynaptic_ind'] = self._connections['presynaptic_ind'].astype(np.uint32)
    #     self._connections['postsynaptic_ind'] = self._connections['postsynaptic_ind'].astype(np.uint32)
    #
    #     if verbose_level == 0:
    #         print('\nBrain: self._connections dataframe with ' + str(len(self._connections)) +
    #               ' connections has been generated.')
    #     if verbose_level == 1:
    #         print('\nBrain: self._connections dataframe with ' + str(len(self._connections)) +
    #               ' neurons has been generated.')
    #         print(self._connections)
    #


if __name__ == '__main__':

    # =========================================================================================
    # dfile = h5py.File(r"F:\littlefish\test_folder\neuron_test.hdf5")
    # neuron_group = dfile.create_group('test_neuron')
    # neuron = Neuron()
    # for i in range(SIMULATION_LENGTH):
    #     neuron.act(i)
    # neuron.to_h5_group(neuron_group)
    # =========================================================================================

    # =========================================================================================
    # connection = Connection(amplitude=10, latency=5)
    # print(connection.get_psp())
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 50
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    # connection = Connection(amplitude=10, latency=5, rise_time=5, decay_time=10)
    # connection.act(2, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(4, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(40, postsynaptic_input)
    # print(postsynaptic_input)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 5000
    # neuron_pre = Neuron(baseline_rate=0.005)
    # neuron_post = Neuron(baseline_rate=0.000)
    # connection = Connection(amplitude=1, latency=5, rise_time=1, decay_time=1)
    #
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    #
    # for i in range(SIMULATION_LENGTH):
    #
    #     is_firing = neuron_pre.act(i)
    #     if is_firing:
    #         connection.act(i, postsynaptic_input)
    #     neuron_post.act(i, probability_input=postsynaptic_input[i])
    #
    # spk_train_pre = neuron_pre.get_action_history()
    # spk_train_post = neuron_post.get_action_history()
    #
    # # print(postsynaptic_input)
    # print(len(spk_train_pre))
    # print(len(spk_train_post))
    #
    # ccg, t = util.discreat_crosscorrelation(np.array(spk_train_pre), np.array(spk_train_post))
    # plt.bar(t, ccg)
    # plt.show()
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # terrain_map = np.zeros((5, 5), dtype=np.uint8)
    # terrain_map[3, 3] = 1
    # print(terrain_map)
    #
    # eye = Eye(position=(2, 3), direction='south')
    # print(eye._get_input(terrain_map=terrain_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(i, terrain_map=terrain_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 20000
    # muscle = Muscle(direction='east', baseline_rate=0., refractory_period=5000)
    # movements = []
    # for i in range(SIMULATION_LENGTH):
    #     movement=muscle.act(i, probability_input=0.5, probability_base=0.1)
    #     if movement:
    #         movements.append(movement)
    # print(movements)
    # print(muscle.get_action_history())
    # =========================================================================================

    # =========================================================================================
    # brain = Brain()
    # neurons_df = brain.generate_default_neurons_df()
    # connections_df = brain.generate_default_connections_df(neurons_df)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # terrain_map = np.zeros((5, 5), dtype=np.uint8)
    # terrain_map[3, 3] = 1
    # print(terrain_map)
    #
    # eye = Eye2(direction='south')
    # position = (2, 3)
    # print(eye._get_input_pixels(position=position, terrain_map=terrain_map))
    # print(eye._get_input(position=position, terrain_map=terrain_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(t_point=i, position=position, terrain_map=terrain_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    brain = Brain()
    # print(brain.has_action_histories())
    # brain._generate_empty_psp_waveforms()
    # print(brain.get_neuron_indices(2))
    # print(brain.get_all_presynaptic_neuron_indices())
    # print(brain.get_all_postsynaptic_neuron_indices())
    # print(brain.get_eye_type(13))
    # print(brain.layer_num)
    # print(brain.get_postsynaptic_neuron_ind(8))
    # print(brain.get_presynaptic_neuron_ind(8))
    # print(brain.get_single_connection(8, 13))
    # print(brain.get_single_connection(8, 16))
    # print(brain.get_neuron_inds_in_layer(3))
    #
    # test_file_path = r"F:\littlefish\test_folder\brain_test.hdf5"
    # if os.path.isfile(test_file_path):
    #     os.remove(test_file_path)
    # test_file = h5py.File(test_file_path)
    # brain_group = test_file.create_group('brain')
    # brain.to_h5_group(brain_group)
    # test_file.close()
    # =========================================================================================

    print('debug...')
