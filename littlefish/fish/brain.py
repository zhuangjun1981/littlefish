# from __future__ import (absolute_import, division,
#                         print_function, unicode_literals)
# from builtins import *

import os
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import littlefish.utilities as util
import h5py


# consider one time unit is 0.1 milisecond, time unit should be small enough that no more than one action is possible
# per time unit
# SIMULATION_LENGTH = int(1e5)  # number of time units in simulation

# unnecessary global variable
# EYE_GAIN = 0.005
# EYE_BASELINE_RATE = 0.
# EYE_REFRACTORY_PERIOD = 10
# EYE_BORDER_VALUE = 1
# EYE_INPUT_FILTER = np.array([0.2, 0.6, 0.2])
# EYE2_INPUT_FILTER = np.array([0.15, 0.3, 0.15, 0.1, 0.2, 0.1])
# EYE_DIRECTIONS = ['east', 'northeast', 'north', 'northwest', 'west', 'southwest', 'south', 'southeast']
# EYE_INPUT_TYPES = ['terrain', 'food', 'fish']
#
# NEURON_REFRACTORY_PERIOD = 10
# NEURON_BASELINE_RATE = 0.0001
#
# MUSCLE_DIRECTIONS = ['east', 'north', 'west', 'south']
# MUSCLE_REFRACTORY_PERIOD = 5000
# MUSCLE_BASELINE_RATE = 0.00001
#
# CONNECTION_LATENCY = 30
# CONNECTION_AMPLITUDE = 0.0001
# CONNECTION_RISE_TIME = 50
# CONNECTION_DECAY_TIME = 100

def generate_minimal_brain():
    """
    :return: a Brain object with one eye, two neuron in hidden layer and one muscle 
    """

    eye = Eye2(direction='east', input_filter=np.array([0.15, 0.3, 0.15, 0.1, 0.2, 0.1]), gain=0.05,
                     input_type='terrain', baseline_rate=0., refractory_period=10)
    hidden0 = Neuron(baseline_rate=0.0005, refractory_period=10)
    hidden1 = Neuron(baseline_rate=0.0005, refractory_period=10)
    muscle = Muscle(direction='east', baseline_rate=0.1, refractory_period=5000)

    neurons = pd.DataFrame([[0, 0, eye],
                            [1, 0, hidden0],
                            [1, 1, hidden1],
                            [2, 0, muscle]], columns=['layer', 'neuron_ind', 'neuron'])

    connection_eye_hidden0 = Connection(latency=30, amplitude=0.01, rise_time=50, decay_time=100)
    connection_eye_hidden1 = Connection(latency=30, amplitude=0.0001, rise_time=50, decay_time=100)
    connection_hidden0_muscle = Connection(latency=30, amplitude=0.0001, rise_time=50, decay_time=100)
    connection_hidden1_muscle = Connection(latency=30, amplitude=0.01, rise_time=50, decay_time=100)

    conn_0_1 = pd.DataFrame([[connection_eye_hidden0], [connection_eye_hidden1]], columns=[0], index=[1, 2])
    conn_1_2 = pd.DataFrame([[connection_hidden0_muscle, connection_hidden1_muscle]], columns=[1, 2], index=[3])

    connections = {'L000_L001': conn_0_1,
                   'L001_L002': conn_1_2}

    return Brain(neurons=neurons, connections=connections)


def generate_default_terrain_food_brain():
    """
    
    :return: 
    """


class Neuron(object):
    """
    a very simple neuron class
    """

    def __init__(self, baseline_rate=0.0001, refractory_period=10):
        """
        action is the equivalent of action potential in biology, and consider one time unit is 0.1 milisecond

        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        self._baseline_rate = float(baseline_rate)
        self._refractory_period = float(refractory_period)

        # action history has been moved to simulation
        # self._action_history = []

    def __str__(self):
        return 'littlefish.brain.Neuron object'

    def get_baseline_rate(self):
        return self._baseline_rate

    def get_refractory_period(self):
        return self._refractory_period

    def act(self, t_point, action_history=[], probability_input=0., probability_base=None):
        """
        evaluate if the neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param action_history: list of positive integers, list of time stamps of actions of this neuron,
                               should be monotonically increasing
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: bool, True: fire; False: quite
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise ValueError('Neuron: probability_base should be no less than 0 and less than 1.')

        if len(action_history) >= 2:
            if not util.check_monotonicity(np.array(action_history), direction='increasing'):
                raise ValueError('Neuron: action history should be monotonically increasing.')

        if len(action_history) > 0 and t_point - action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                action_history.append(t_point)
                return True
            else:
                return False

    def to_h5_group(self, h5_group):

        br_dset = h5_group.create_dataset('baseline_rate', data=self._baseline_rate)
        br_dset.attrs['unit'] = 'action_per_time_unit'
        rp_dset = h5_group.create_dataset('refractory_period', data=self._refractory_period)
        rp_dset.attrs['unit'] = 'time_unit'
        h5_group.attrs['neuron_type'] = 'neuron'

    @staticmethod
    def from_h5_group(h5_group):

        if h5_group.attrs['neuron_type'] != 'neuron':
            raise ValueError('Neuron: loading from h5 file failed. "neuron_type" attribute should be "neuron".')

        neuron = Neuron(baseline_rate=h5_group['baseline_rate'], refractory_period=h5_group['refractory_period'])
        return neuron


class Eye(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 1 pixel
    """

    def __init__(self, direction, input_filter=None, gain=None, input_type=None, baseline_rate=None,
                 refractory_period=None):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 3 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        0 0 0 0 0 0 0
        0 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        :param input_type: str, type of the input the eye receives, should be one of 'terrain', 'food', 'fish',
               default: 'terrain'
        """

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise ValueError("direction should be one of the following: ['north', 'south', 'east', 'west', "
                             "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = np.array([0.2, 0.6, 0.2])
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

        if input_type is None:
            self._input_type = 'terrain'
        elif input_type in ['terrain', 'food', 'fish']:
            self._input_type = input_type
        else:
            raise ValueError('Eye2: type should be one of the following: "terrain", "food", "fish".')

        if baseline_rate is None:
            curr_baseline_rate = 0.
        else:
            curr_baseline_rate = float(baseline_rate)

        if refractory_period is None:
            curr_refractory_period = 10
        else:
            curr_refractory_period = int(refractory_period)

        super(Eye, self).__init__(baseline_rate=curr_baseline_rate, refractory_period=curr_refractory_period)

    def __str__(self):
        return 'littlefish.brain.Eye object'

    def _get_input_pixels(self, input_map, position, border_value=1):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the
        input_map range will be returned as border_value
        """
        
        if len(position) != 2:
            raise ValueError('position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise ValueError('Elements in position should both be integers.')

        if len(input_map.shape) != 2:
            raise ValueError('terrain_map should a 2-d array.')
        
        if position[0] < 0 or position[0] >= input_map.shape[0] or \
                position[1] < 0 or position[1] >= input_map.shape[1]:
            raise ValueError('position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1]]
        elif self._direction == 'northeast':
            ind = [[position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1]]
        elif self._direction == 'southwest':
            ind = [[position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1]]
        else:
            raise ValueError("direction should be one of the following: ['north', 'south', 'east', 'west', "
                             "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= input_map.shape[0] or cor[1] < 0 or cor[1] >= input_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(input_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, input_map, position, border_value=1):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(input_map, position, border_value=border_value)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def act(self, t_point, input_map, position, action_history=[], border_value=1, probability_base=None):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param input_map: binary 2-d map, for now it should only contain 0s and 1s
        :param action_history: list of positive integers, list of time stamps of actions of this neuron,
                               should be monotonically increasing
        :param border_value: int, default 1, value for pixels outside the terrain_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(input_map, position, border_value=border_value)

        super(Eye, self).act(t_point=t_point, action_history=action_history, probability_input=probability_input,
                             probability_base=probability_base)


class Eye2(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 2 pixels
    """

    def __init__(self, direction, input_filter=None, gain=None, input_type=None, baseline_rate=None,
                 refractory_period=None):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 6 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        3 3 0 0 0 0 0
        3 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        :param input_type: str, type of the input the eye receives, should be one of 'terrain', 'food', 'fish',
               default: 'terrain'
        """

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise ValueError("direction should be one of the following: ['north', 'south', 'east', 'west', "
                             "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = np.array([0.15, 0.3, 0.15, 0.1, 0.2, 0.1])
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

        if input_type is None:
            self._input_type = 'terrain'
        elif input_type in ['terrain', 'food', 'fish']:
            self._input_type = input_type
        else:
            raise ValueError('Eye2: type should be one of the following: "terrain", "food", "fish".')

        if baseline_rate is None:
            curr_baseline_rate = 0.
        else:
            curr_baseline_rate = float(baseline_rate)

        if refractory_period is None:
            curr_refractory_period = 10
        else:
            curr_refractory_period = int(refractory_period)

        super(Eye2, self).__init__(baseline_rate=curr_baseline_rate, refractory_period=curr_refractory_period)

    def __str__(self):
        return 'littlefish.brain.Eye2 object'

    def _get_input_pixels(self, input_map, position, border_value=1):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the
        input_map range will be returned as border_value
        """

        if len(position) != 2:
            raise ValueError('Eye2: position should have 2 elements.')

        if util.is_integer(position[0]) and util.is_integer(position[1]):
            self._position = position
        else:
            raise ValueError('Eye2: Elements in position should both be integers.')

        if len(input_map.shape) != 2:
            raise ValueError('Eye2: terrain_map should a 2-d array.')

        if position[0] < 0 or position[0] >= input_map.shape[0] or \
                position[1] < 0 or position[1] >= input_map.shape[1]:
            raise ValueError('Eye2: position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] + 1, position[1] + 2],
                   [position[0], position[1] + 2],
                   [position[0] - 1, position[1] + 2]]
        elif self._direction == 'northeast':
            ind = [[position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] + 2],
                   [position[0] - 2, position[1] + 2],
                   [position[0] - 2, position[1] + 1]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0] - 2, position[1] + 1],
                   [position[0] - 2, position[1]],
                   [position[0] - 2, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] - 2, position[1] - 1],
                   [position[0] - 2, position[1] - 2],
                   [position[0] - 1, position[1] - 2]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] - 1, position[1] - 2],
                   [position[0], position[1] - 2],
                   [position[0] + 1, position[1] - 2]]
        elif self._direction == 'southwest':
            ind = [[position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] - 2],
                   [position[0] + 2, position[1] - 2],
                   [position[0] + 2, position[1] - 2]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0] + 2, position[1] - 1],
                   [position[0] + 2, position[1]],
                   [position[0] + 2, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] + 2, position[1] + 1],
                   [position[0] + 2, position[1] + 2],
                   [position[0] + 1, position[1] + 2]
                   ]
        else:
            raise ValueError("Eye2: direction should be one of the following: ['north', 'south', 'east', 'west', "
                             "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= input_map.shape[0] or cor[1] < 0 or cor[1] >= input_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(input_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, input_map, position, border_value=1):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(input_map, position, border_value=border_value)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def get_position(self, body_position):
        """
        :param body_position: tuple of two ints, (row, col)
        :return: eye position given body position accroding its direction
        """
        if len(body_position) != 2:
            raise ValueError('Eye2: body_position should contain two elements.')

        if (not util.is_integer(body_position[0])) or (not util.is_integer(body_position[1])):
            raise ValueError('Eye2: body_position should contain two integers.')

        if self._direction == 'east':
            return body_position[0], body_position[1] + 1
        elif self._direction == 'northeast':
            return body_position[0] - 1, body_position[1] + 1
        elif self._direction == 'north':
            return body_position[0] - 1, body_position[1]
        elif self._direction == 'northwest':
            return body_position[0] - 1, body_position[1] - 1
        elif self._direction == 'west':
            return body_position[0], body_position[1] - 1
        elif self._direction == 'southwest':
            return body_position[0] + 1, body_position[1] - 1
        elif self._direction == 'south':
            return body_position[0] + 1, body_position[1]
        elif self._direction == 'southeast':
            return body_position[0] + 1, body_position[1] + 1
        else:
            raise ValueError("Eye2: direction should be one of the following: ['north', 'south', 'east', 'west', "
                             "'northwest', 'northeast', 'southwest', 'southeast'].")

    def get_input_type(self):
        return self._input_type

    def act(self, t_point, position, input_map, action_history=[], border_value=1, probability_base=None):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param input_map: binary 2-d map, for now it should only contain 0s and 1s
        :param action_history: list of positive integers, list of time stamps of actions of this neuron,
                               should be monotonically increasing
        :param border_value: int, default 1, value for pixels outside the terrain_map
        :param probability_base
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(input_map, position, border_value=border_value)

        return super(Eye2, self).act(t_point, action_history=action_history, probability_input=probability_input,
                                     probability_base=probability_base)

    def to_h5_group(self, h5_group):

        br_dset = h5_group.create_dataset('baseline_rate', data=self._baseline_rate)
        br_dset.attrs['unit'] = 'action_per_time_unit'
        rp_dset = h5_group.create_dataset('refractory_period', data=self._refractory_period)
        rp_dset.attrs['unit'] = 'time_unit'
        h5_group.create_dataset('direction', data=self._direction)
        h5_group.create_dataset('input_filter', data=self._input_filter)
        h5_group.create_dataset('gain', data=self._gain)
        h5_group.create_dataset('input_type', data=self._input_type)
        h5_group.attrs['neuron_type'] = 'eye2'

    @staticmethod
    def from_h5_group(h5_group):

        if h5_group.attrs['neuron_type'] != 'eye2':
            raise ValueError('Eye2: loading from h5 file failed. "neuron_type" attribute should be "eye2".')

        eye2 = Eye2(direction=h5_group['direction'], input_filter=h5_group['input_filter'], gain=h5_group['gain'],
                    input_type=h5_group['input_type'], baseline_rate=h5_group['baseline_rate'],
                    refractory_period=h5_group['refractory_period'])
        return eye2


class Muscle(Neuron):
    """
    muscle class for determining the motion of the fish. Subclass of Neuron class
    """

    def __init__(self, direction, baseline_rate=0.0001, refractory_period=5000):

        if direction in ['east', 'north', 'west', 'south']:
            self._direction = direction
        else:
            raise ValueError("direction should be one of the following: ['east', 'north', 'west', 'south'].")

        super(Muscle, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

    def __str__(self):
        return 'littlefish.brain.Muscle object'

    def act(self, t_point, action_history=[], probability_input=0., probability_base=None):
        """
        evaluate if the muscle will try to move the fish or not
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param action_history: list of positive integers, list of time stamps of actions of this neuron,
                               should be monotonically increasing
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: no attempt: False
                 attempt: movement vector, 1d array with two ints, [row_update, col_update]
        """

        is_act = super(Muscle, self).act(t_point, action_history=action_history, probability_input=probability_input,
                                         probability_base=probability_base)

        if is_act:
            if self._direction == 'east':
                return np.array([0, 1], dtype=np.uint8)
            elif self._direction == 'north':
                return np.array([-1, 0], dtype=np.uint8)
            elif self._direction == 'west':
                return np.array([0, -1], dtype=np.uint8)
            elif self._direction == 'south':
                return np.array([1, 0], dtype=np.uint8)
            else:
                raise ValueError("self.direction should be one of the following: "
                                 "['east', 'north', 'west', 'south'].")
        else:
            return is_act

    def to_h5_group(self, h5_group):

        br_dset = h5_group.create_dataset('baseline_rate', data=self._baseline_rate)
        br_dset.attrs['unit'] = 'action_per_time_unit'
        rp_dset = h5_group.create_dataset('refractory_period', data=self._refractory_period)
        rp_dset.attrs['unit'] = 'time_unit'
        h5_group.create_dataset('direction', data=self._direction)
        h5_group.attrs['neuron_type'] = 'muscle'

    @staticmethod
    def from_h5_group(h5_group):

        if h5_group.attrs['neuron_type'] != 'muscle':
            raise ValueError('Muscle: loading from h5 file failed. "neuron_type" attribute should be "muscle".')

        muscle = Muscle(direction=h5_group['direction'], baseline_rate=h5_group['baseline_rate'],
                        refractory_period=h5_group['refractory_period'])
        return muscle


class Connection(object):
    """
    synaptic connection between two neurons
    """

    def __init__(self, latency=30, amplitude=0.0001, rise_time=50, decay_time=100):
        """

        :param latency: int, temporal latency from presynaptic neuron action to the postsynaptic effect onset, number
                        of time units
        :param amplitude: float, peak change of the firing rate in the postsynaptic neuron, probablity of a action per
                          time unit. can be positive (excitatiory) or negative (inhibitory)
        :param rise_time: int, temporal duration from onset to peak, number of time units
        :param decay_time: int, temporal duration from peak to baseline, number of time units
        """

        if latency is not None:
            if not isinstance(latency, int):
                raise ValueError('latency should be an integer.')
            self._latency = latency

        if amplitude is not None:
            self._amplitude = float(amplitude)

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise ValueError('rise_time should be an integer.')
            self._rise_time = rise_time

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise ValueError('decay_time should be an integer.')
            self._decay_time = decay_time

        self._generate_psp()

    def __str__(self):
        return 'littlefish.brain.Connection object'

    def get_latency(self):
        return self._latency

    def get_amplitude(self):
        return self._amplitude

    def get_rise_time(self):
        return self._rise_time

    def get_decay_time(self):
        return self._decay_time

    def _generate_psp(self):
        """
        generate post synaptic probability wave form
        """

        self._psp = np.zeros(self._latency + self._rise_time + self._decay_time)
        self._psp[self._latency: self._latency + self._rise_time] = self._amplitude * \
            (np.arange(self._rise_time) + 1).astype(np.float32) / float(self._rise_time)
        self._psp[-self._decay_time:] = self._amplitude * \
            (np.arange(self._decay_time, 0, -1) - 1).astype(np.float32) / float(self._decay_time)

    def get_psp(self):
        return self._psp

    def set_params(self, latency=None, amplitude=None, rise_time=None, decay_time=None):
        """
        set new parameters and regenerate psp waveform

        :param latency: int, number of time units for time delay
        :param amplitude: float, peak probability
        :param rise_time: int, number of time units to rise to peak
        :param decay_time: int, number of time units to decay to baseline
        """

        changed = False

        if latency is not None:
            if not isinstance(latency, int):
                raise ValueError('latency should be an integer.')
            self._latency = latency
            changed = True

        if amplitude is not None:
            self._amplitude = float(amplitude)
            changed = True

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise ValueError('rise_time should be an integer.')
            self._rise_time = rise_time
            changed = True

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise ValueError('decay_time should be an integer.')
            self._decay_time = decay_time
            changed = True

        if changed:
            self._generate_psp()
        else:
            print('Brain.Connection: no parameter has been changed. Do nothing.')

    def act(self, t_point, postsynaptic_index, psp_waveforms):
        """
        if the presynaptic neuron fires at the 'time_point', a psp wave form will be generated and add to the
        input waveform of postsynaptic neuron defined by postsynaptic_index
        :param t_point: int, current time point as the index of time unit axis
        :param postsynaptic_index: non-negative int, the index of postsynaptic neuron
        :param psp_waveforms: 2-d array, float 32, the psp waveforms of all neurons in the brain, neuron id x t-point,
                              the generated psp will be added to the postsynaptic_index th line of the array
        :return:
        """
        psp_end = t_point + len(self._psp)
        if psp_end <= psp_waveforms.shape[1]:
            psp_waveforms[postsynaptic_index, t_point: psp_end] += self._psp
        else:
            psp_waveforms[postsynaptic_index, t_point:] += self._psp[:psp_waveforms.shape[1] - t_point]


class Brain(object):
    """
    brain class, the neural network from eye to muscle

    a 'brain' has a couple of sets of 8 eyes (brain.Eye object, each at each border pixel of the body). each set of
    eyes are receiving inputs from different objects. i.e. one set of eyes will look at land/water, another set of eyes
    will look for food, another set of eyes will look for other fish.

    a 'brain' has 4 invisible muscles (brain.Muscle object, each controlling the movement in each direction).

    between eyes and muscles are a neural network consists of neurons (brain.Neuron object) and connections
    (brain.Connections object). Number of layers and number of neurons can be specified.
    """

    def __init__(self, neurons=None, connections=None):
        """

        :param neurons: pandas dataframe
        :param connections: dict
        """
        if neurons is None:
            self._neurons = self._generate_default_neurons()
            print('\nBrain: a dataframe with 28 default neurons and 3 layers (eye, hidden, muscle) has been generated.')
        else:
            self._neurons = neurons


        if connections is None:
            self._connections = self._generate_default_connections()
            conn_num = [conn.size for conn in self._connections.values()]
            conn_num = sum(conn_num)
            print('\nBrain: a dataframe of default ' + str(conn_num) +
                  ' connections among self._neurons has been generated')
        else:
            self._connections = connections

        self.check_integrity()

    def __str__(self):
        return 'littlefish.brain.Brain object'

    def _generate_default_neurons(self):
        """
        generate and return a dataframe containing all neurons with default parameters
        """
        neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'neuron'])

        ind = 0
        for i in range(16):
            curr_dir, curr_type = self.get_eye_type(i)
            neurons.loc[ind] = [0, i, Eye2(direction=curr_dir)]
            ind += 1

        for i in range(8):
            neurons.loc[ind] = [1, i, Neuron()]
            ind += 1

        for i in range(4):
            curr_dir = self.get_muscle_direction(i)
            neurons.loc[ind] = [2, i, Muscle(direction=curr_dir)]
            ind += 1

        neurons['layer'] = neurons['layer'].astype(np.uint32)
        neurons['neuron_ind'] = neurons['neuron_ind'].astype(np.uint32)

        return neurons

    def _generate_default_connections(self):
        """
        generate all possible connections among self_neurons with default parameters
        """

        connections = {}

        default_connection = Connection()

        for pre_layer in range(self.layer_num - 1):
            post_layer = pre_layer + 1
            post_neuron_inds = self.get_neuron_inds_in_layer(post_layer)
            pre_neuron_inds = self.get_neuron_inds_in_layer(pre_layer)
            curr_name = 'L' + util.int2str(pre_layer, 3) + '_L' + util.int2str(post_layer, 3)
            curr_df = pd.DataFrame([[default_connection] * len(pre_neuron_inds)] * len(post_neuron_inds),
                                   columns=pre_neuron_inds, index=post_neuron_inds)
            connections.update({curr_name: curr_df})

        return connections

    def get_neurons(self):
        return self._neurons

    @property
    def layer_num(self):
        return int(round(max(self._neurons['layer']))) + 1

    def get_layer_type(self, layer):
        """
        return layer type (str) given the layer number
        """
        if not isinstance(layer, int):
            raise ValueError('Input layer number should be integer.')

        if layer == 0:
            return 'eye'
        elif layer == self.layer_num - 1:
            return 'muscle'
        elif 0 < layer < self.layer_num - 1:
            return 'hidden' + util.int2str(layer, 3)
        else:
            raise ValueError('layer number out of range.')

    def get_neuron_type(self, ind):
        """
        return neuron type as a pair of strings given the index in self._neurons
        :param ind: int
        :return: for eyes : ('eye', type + short of direction)
                 for hidden neurons: ('hidden', str(layer))
                 for muscles ('muscle', short of direction)
        """

        self.check_integrity_neurons()

        curr_row = self._neurons.loc[ind]
        curr_layer = curr_row['layer']
        if curr_layer == 0:  # eye layer
            curr_dir, curr_type = self.get_eye_type(curr_row['neuron_ind'])
            return util.short('eye') + '_' + util.short(curr_type) + '_' + util.short(curr_dir)
        elif curr_layer == self.layer_num - 1:  # muscle layer
            curr_dir = self.get_muscle_direction(curr_row['neuron_ind'])
            return util.short('muscle') + '_' + util.short(curr_dir)
        elif 0 < curr_layer < self.layer_num - 1:
            curr_layer_num = util.int2str(curr_layer, 3)
            curr_neuron_num = util.int2str(curr_row['neuron_ind'], 3)
            return '_'.join([util.short('hidden'), curr_layer_num, curr_neuron_num])
        else:
            raise ValueError('layer number out of range.')

    def get_connections(self):
        return self._connections

    def get_postsynaptic_neuron_inds(self, neuron_ind):

        neuron_layer = int(round(self._neurons.loc[neuron_ind, 'layer']))
        if neuron_layer < 0:
            raise ValueError('Brain: invalid layer. less than 0.')
        elif neuron_layer == self.layer_num - 1:
            print('Brain: cannot fine postsynaptic neuron of neurons in muscle layer.')
        else:
            postsynaptic_neuron_ind = self._neurons[self._neurons['layer'] == neuron_layer + 1].index.tolist()
            postsynaptic_neuron_ind.sort()
            return postsynaptic_neuron_ind

    def get_presynaptic_neuron_inds(self, neuron_ind):

        neuron_layer = int(round(self._neurons.loc[neuron_ind, 'layer']))
        if neuron_layer < 0:
            raise ValueError('Brain: invalid layer. less than 0.')
        elif neuron_layer == 0:
            print('Brain: cannot fine presynaptic neuron of neurons in eye layer.')
        else:
            presynaptic_neuron_ind = self._neurons[self._neurons['layer'] == neuron_layer - 1].index.tolist()
            presynaptic_neuron_ind.sort()
            return presynaptic_neuron_ind

    def get_single_connection(self, pre_neuron_ind, post_neuron_ind):

        pre_layer = int(round(self._neurons.loc[pre_neuron_ind, 'layer']))
        post_layer = int(round(self._neurons.loc[post_neuron_ind, 'layer']))

        if post_layer - pre_layer != 1:
            raise LookupError('Brain: presynaptic layer' + str(pre_layer) + ' and postsynaptic layer' +
                              str(post_layer) + ' do not form connections.')

        conn_df = self._connections['L' + util.int2str(pre_layer, 3) + '_L' + util.int2str(post_layer, 3)]
        return conn_df.loc[post_neuron_ind, pre_neuron_ind]

    def get_neuron_inds_in_layer(self, layer):
        """
        return a list of sorted neuron_indices of all neurons in a given layer
        """
        inds = self._neurons[self._neurons['layer'] == layer].index.tolist()
        inds.sort()
        return inds

    def check_integrity(self):
        """
        check integrity of object data structure
        """

        print('\nBrain: checking integrity of attrbitue data structure ...')

        self.check_integrity_neurons(verbose=True)

        self.check_integrity_connection(verbose=True)

        print('Brain: integrity checking finished. All pass.\n')

    def check_integrity_neurons(self, verbose=False):

        if not util.check_df_index(self._neurons):
            raise ValueError('Brain: the indices of self._neurons are not starting at 0 and increasing with step 1.')
        else:
            if verbose:
                print('Brain: the indices of self._neurons are starting at 0 and increasing with step 1. PASS.')
            else:
                pass

        layer = 0
        ind = -1
        for i, neuron in self._neurons.iterrows():
            curr_layer = int(round(neuron['layer']))
            curr_neuron_ind = neuron['neuron_ind']
            if curr_layer < layer:
                raise ValueError('Brain: the "layer" in self._neurons is not in ascending order.')
            elif curr_layer == layer:
                if curr_neuron_ind != ind + 1:
                    raise ValueError('Brain: the "neuron_ind" in self._neurons is not in ascending by step 1 for'
                                     ' each "layer"')
                else:
                    ind += 1
            else:
                layer = curr_layer
                if curr_neuron_ind != 0:
                    raise ValueError('Brain: the "neuron_ind" in self._neurons does not start with 0 for each '
                                     '"layer".')
                ind = 0

            if curr_layer == 0:  # eye layer
                if not (str(neuron['neuron']) == 'littlefish.brain.Eye object' or
                        str(neuron['neuron']) == 'littlefish.brain.Eye2 object'):
                    raise ValueError('Brain: non-eye object in eye layer.')
            elif curr_layer == self.layer_num - 1:  # muscle layer
                if not str(neuron['neuron']) == 'littlefish.brain.Muscle object':
                    raise ValueError('Brain: non-muscle object in muscle layer.')
            else:  # hidden layer
                if not str(neuron['neuron']) == 'littlefish.brain.Neuron object':
                    raise ValueError('Brain: non-neuron object in hidden layer.')

        if verbose:
            print('Brain: the "layer" of self._neurons is in a non-descending order. PASS')
            print('Brain: the "neuron_ind" of self._neurons for each layer is ascending from 0 by step 1. PASS')
            print('Brain: eyes in eye layer, muscles in muscle layer, neurons in hidden layer. PASS')

    def check_integrity_connection(self, verbose=False):

        matching_keys = []
        for i in range(self.layer_num - 1):
            matching_keys.append('L' + util.int2str(i, 3) + '_L' + util.int2str(i+1, 3))
        matching_keys.sort()

        conn_keys = self._connections.keys()
        conn_keys.sort()

        if not conn_keys == matching_keys:
            raise ValueError('Brain: invalid keys in self._connections.')
        else:
            if verbose:
                print('Brain: valid keys in self._connections. PASS')
            else:
                pass

        for key in conn_keys:
            pre_layer = int(key[1: 4])
            post_layer = int(key[6: 9])
            curr_conn_df = self._connections[key]
            pre_neuron_ind = self.get_neuron_inds_in_layer(pre_layer)
            post_neuron_ind = self.get_neuron_inds_in_layer(post_layer)
            if not np.array_equal(pre_neuron_ind, curr_conn_df.columns.tolist()):
                raise ValueError('Brain: connections dataframe ' + key + ' does not have valid column name.')
            if not np.array_equal(post_neuron_ind, curr_conn_df.index.tolist()):
                raise ValueError('Brain: connections dataframe ' + key + ' does not have valid index name.')

        if verbose:
            print('Brain: dataframes in self._connections have valid column and index names. PASS')

    def act(self, t_point, action_histories, psp_waveforms, body_position, terrain_map, food_map=None,
            fish_map=None):
        """
        :param t_point: int, current time stamp of time unit axis
        :param action_histories: data frame of lists, each list is the action history of a particular neuron, in the
                                 same order as self._neurons data frame, columns = ['action_history']
        :param psp_waveforms: 2d-array of floats, psp waveforms of all neurons in the brain, each row represents one
                              neuron in the same order as self._neurons data frame, each column represents a time point
        :param body_position: tuple of two ints, (row, col), current position of body center of the fish
        :param terrain_map: 2d array, with only 0s (water) and 1s (land). represents the land scape of the world
        :param food_map: 2d array, with only 0s (no food) and 1s (food). represents the distribution of food
        :param fish_map: not fully implemented right now.
        :return: movement attemps: 2-d array, np.uint8, (row, col), representing the movement attempt, be careful, this may not
                                   represent the actual movement, it will be evaluated by the fish object (fish class)
                                   containing this brain to see if the movement is possible. if the fish is hitting
                                   the edge the world map, then the it will not move out of the map
                                   None: no movement has been attempted,
        """

        movement_attempt = np.array([0, 0], dtype=np.uint8)

        for i, neuron in self._neurons.iterrows():

            if neuron['layer'] == 0:  # eye layer
                curr_eye = neuron['neuron']
                curr_eye_pos = curr_eye.get_position(body_position=body_position)

                if curr_eye.get_input_type() == 'terrain':
                    is_fire = curr_eye.act(t_point=t_point, action_history=action_histories.iloc[i, 0],
                                           position=curr_eye_pos, input_map=terrain_map)
                elif curr_eye.get_input_type() == 'food':
                    if food_map is not None:
                        is_fire = curr_eye.act(t_point=t_point, action_history=action_histories[i, 'action_history'],
                                               position=curr_eye_pos, input_map=food_map)
                    else:
                        is_fire = False
                elif curr_eye.get_input_type() == 'fish':
                    if fish_map is not None:
                        is_fire = curr_eye.act(t_point=t_point, action_history=action_histories[i, 'action_history'],
                                               position=curr_eye_pos, input_map=fish_map)
                    else:
                        is_fire = False
                else:
                    raise ValueError('Brain: the input_type of eye should be one of the following:'
                                     '"terrain", "food" or "fish".')

                if is_fire:  # the current eye fires
                    # print('eye spike')
                    self.neuron_fire(presynaptic_neuron_ind=i, t_point=t_point, psp_waveforms=psp_waveforms)

            elif neuron['layer'] < self.layer_num - 1:  # hidden layer
                curr_neuron = neuron['neuron']
                is_fire = curr_neuron.act(t_point=t_point, action_history=action_histories.iloc[i, 0],
                                          probability_input=psp_waveforms[i, t_point])
                if is_fire:
                    # print('neuron spike')
                    self.neuron_fire(presynaptic_neuron_ind=i, t_point=t_point, psp_waveforms=psp_waveforms)

            elif neuron['layer'] == self.layer_num - 1:  # muscle layer
                curr_muscle = neuron['neuron']
                curr_movement_attempt = curr_muscle.act(t_point=t_point,
                                                        action_history=action_histories.iloc[i, 0],
                                                        probability_input=psp_waveforms[i, t_point])
                if curr_movement_attempt is not False:
                    # print('muscle spike')
                    movement_attempt = movement_attempt + curr_movement_attempt

            else:
                raise ValueError('Brain: neuron at index' + str(i) + ' has invalid layer location.')

        return movement_attempt

    def neuron_fire(self, presynaptic_neuron_ind, t_point, psp_waveforms):
        """
        updata all corresponding psp waveforms when a presynaptic neuron (only in eye layer and hidden layer) fires
        :param presynaptic_neuron_ind: int, the index of presynaptic neuron in self._neurons
        :param t_point: int, time point in time unit axis of the action
        :param psp_waveforms: 2d-array of floats, psp waveforms of all neurons in the brain, each row represents one
                              neuron in the same order as self._neurons data frame, each column represents a time point
        :return: None
        """

        neuron_layer = int(round(self._neurons.loc[presynaptic_neuron_ind, 'layer']))

        if 0 <= neuron_layer < self.layer_num - 1:  # eye layer or hidden layer
            curr_conn_df = self._connections['L' + util.int2str(neuron_layer, 3) +
                                             '_L' + util.int2str(neuron_layer + 1, 3)]
            postsynaptic_neuron_inds = self.get_postsynaptic_neuron_inds(neuron_ind=presynaptic_neuron_ind)

            for postsynaptic_neuron_ind in postsynaptic_neuron_inds:
                curr_connection = curr_conn_df.loc[postsynaptic_neuron_ind, presynaptic_neuron_ind]
                curr_connection.act(t_point=t_point, postsynaptic_index=postsynaptic_neuron_ind,
                                    psp_waveforms=psp_waveforms)
        elif neuron_layer == self.layer_num - 1:  # muscle layer
            print('Brain: a firing of a muscle has no effect on brain itself. Please use Muscle.act() method to '
                  'generate movement attempt.')
        else:
            raise ValueError('Brain: neuron at index' + str(presynaptic_neuron_ind) + ' has invalid layer location.')

    def get_all_presynaptic_neuron_indices(self):
        """
        get indices of all presynaptic neurons
        """
        layer_num = int(max(self._neurons['layer'])) + 1
        ind = self._neurons[self._neurons['layer'] < layer_num - 1].index
        return ind.sort_values()

    def get_all_postsynaptic_neuron_indices(self):
        """
        get indices of all postsynaptic neurons
        """
        ind = self._neurons[self._neurons['layer'] > 0].index
        return ind.sort_values()

    # def plot_action_histories_scatter(self, plot_length, plot_axis=None, is_separated=True, **kwargs):
    #     """
    #     plot action histories of all neurons as scatter plot, eye spikes: red, hidden layer spikes: green,
    #     muscle spikes: blue
    #     :param plot_length: int, total length of plot, number of time units
    #     :param is_separated: bool, plot separation line or not
    #     :param plot_axis: matplotlib.pyplot.axis object
    #     :param kwargs: other inputs to matplotlib.pyplot.plot function
    #     :return:
    #     """
    #
    #     if not self.has_action_histories():
    #         print('Brain: No action history found. Cannot plot. Do nothing.')
    #         return
    #
    #     self.check_integrity_neurons()
    #
    #     if plot_axis is None:
    #         f = plt.figure(figsize=(15, 10))
    #         plot_axis = f.add_subplot(111)
    #
    #     if plot_length is None:
    #         plot_length = self._psp_waveforms.shape[1]
    #
    #     total_neuron_num = len(self._neurons)
    #     total_y = range(total_neuron_num)
    #
    #     if is_separated:
    #         total_separation = [y + 0.5 for y in total_y]
    #         for separation in total_separation:
    #             plot_axis.plot([0, plot_length], [separation, separation], '--', color='#888888')
    #
    #     yticklaybels = []
    #
    #     for i, neuron_df in self._neurons.iterrows():
    #         curr_layer_type = self.get_layer_type(int(neuron_df['layer']))
    #         curr_action_history = neuron_df['neuron'].get_action_history()
    #         curr_y = total_y[i]
    #
    #         if 'eye' in curr_layer_type:
    #             util.plot_spike_ticks(curr_action_history, y=curr_y, plot_axis=plot_axis, color='r', **kwargs)
    #         elif 'hidden' in curr_layer_type:
    #             util.plot_spike_ticks(curr_action_history, y=curr_y, plot_axis=plot_axis, color='g', **kwargs)
    #         elif 'muscle' in curr_layer_type:
    #             util.plot_spike_ticks(curr_action_history, y=curr_y, plot_axis=plot_axis, color='b', **kwargs)
    #
    #         yticklaybels.append(self.get_neuron_type(i))
    #
    #     plot_axis.set_xlim([0, plot_length])
    #     plot_axis.set_ylim([-0.5, total_neuron_num - 0.5])
    #     plot_axis.invert_yaxis()
    #     plot_axis.set_xlabel('time (time unit)')
    #     plot_axis.set_ylabel('neuron index')
    #     plot_axis.set_yticks(total_y)
    #     plot_axis.set_yticklabels(yticklaybels, family='monospace')

    def get_connection_matrices(self, pre_layer, post_layer):
        """
        return several numpy arrays each represent one parameter of all connections between a presynaptic layer and
        a postsynaptic layer, each row is a postsynaptic neuron, each column is a presynaptic neuron

                       pre neuron 0,  pre neuron 1,  pre neuron 2,  ... ,  pre neuron m
        post neuron 0
        post neuron 1
        post neuron 2
        ...
        post neuron n

        :param pre_layer: int, layer number of presynaptic layer
        :param post_layer: int, layer number of postsynaptic layer
        :return: rows, list of ints, postsynaptic neuron inds for each row
                 cols, list of ints, presynaptic neuron inds for each column
                 latencies, amplitudes, rise_times, decay_times: matrices for each connection parameter as described
                 above
        """

        self.check_integrity_neurons()
        self.check_integrity_connection()

        rows = self.get_neuron_inds_in_layer(post_layer)
        cols = self.get_neuron_inds_in_layer(pre_layer)

        latencies = np.empty((len(rows), len(cols)), dtype=np.uint)
        amplitudes = np.empty((len(rows), len(cols)), dtype=np.float)
        rise_times = np.empty((len(rows), len(cols)), dtype=np.uint)
        decay_times = np.empty((len(rows), len(cols)), dtype=np.uint)

        conn_df = self._connections['L' + util.int2str(pre_layer, 3) + '_L' + util.int2str(post_layer, 3)]

        for i in range(conn_df.shape[0]):
            for j in range(conn_df.shape[1]):
                latencies[i, j] = conn_df.iloc[i, j].get_latency()
                amplitudes[i, j] = conn_df.iloc[i, j].get_amplitude()
                rise_times[i, j] = conn_df.iloc[i, j].get_rise_time()
                decay_times[i, j] = conn_df.iloc[i, j].get_decay_time()
        return rows, cols, latencies, amplitudes, rise_times, decay_times

    def to_h5_group(self, h5_group):

        neuron_group = h5_group.create_group('neurons')
        for i, neuron_df in self._neurons.iterrows():
            neuron_name = 'neuron_' + util.int2str(i, 5)
            curr_neuron_group = neuron_group.create_group(neuron_name)
            neuron_df['neuron'].to_h5_group(curr_neuron_group)
            curr_neuron_group.attrs['ind'] = i
            curr_neuron_group.attrs['layer'] = neuron_df['layer']
            curr_neuron_group.attrs['neuron_ind'] = neuron_df['neuron_ind']

        connection_group = h5_group.create_group('connections')
        for pre_layer in range(self.layer_num-1):
            post_layer = pre_layer + 1
            curr_connection_matrices = self.get_connection_matrices(pre_layer=pre_layer, post_layer=post_layer)

            curr_layer_group = connection_group.create_group('L' + util.int2str(pre_layer, 3) +
                                                             '_L' + util.int2str(post_layer, 3))
            curr_layer_group.attrs['rows'] = curr_connection_matrices[0]
            curr_layer_group.attrs['cols'] = curr_connection_matrices[1]
            curr_layer_group.attrs['doc'] = 'rows: indices of postsynatpic neurons in the neuron group; ' \
                                            'cols: indices of presynaptic neurons in the neuron group.'
            curr_layer_group.create_dataset(name='latencies_tu', data=curr_connection_matrices[2])
            curr_layer_group.create_dataset(name='amplitudes', data=curr_connection_matrices[3])
            curr_layer_group.create_dataset(name='rise_times_tu', data=curr_connection_matrices[4])
            curr_layer_group.create_dataset(name='decay_times_tu', data=curr_connection_matrices[5])

    @staticmethod
    def get_eye_type(ind):
        """
        given the neuron_ind in the eye layer return direction and input type of a specific eye
        :return: two strings, (direction, type)
        """
        eye_directions = ['east', 'northeast', 'north', 'northwest', 'west', 'southwest', 'south', 'southeast']
        eye_types = ['terrain', 'food', 'fish']
        direction_num = len(eye_directions)
        type_num = len(eye_types)
        return eye_directions[ind % direction_num], eye_types[(ind // direction_num) % type_num]

    @staticmethod
    def get_muscle_direction(ind):
        """
        given the neuron_ind in the muscle layer return direction of a specific muscle
        :return: string, direction of the muscle
        """
        muscle_directions = ['east', 'north', 'west', 'south']
        direction_num = len(muscle_directions)
        return muscle_directions[ind % direction_num]

    @staticmethod
    def from_h5_group(h5_group):
        neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'neuron'])

        neurons_group = h5_group['neurons']
        neuron_names = neurons_group.keys()
        neuron_names.sort()
        for neuron_name in neuron_names:
            curr_neuron_group = neurons_group[neuron_name]
            curr_layer = curr_neuron_group.attrs['layer']
            curr_neuron_ind = curr_neuron_group.attrs['neuron_ind']
            curr_ind = curr_neuron_group.attrs['ind']
            if curr_neuron_group.attrs['neuron_type'] == 'neuron':
                curr_neuron = Neuron.from_h5_group(curr_neuron_group)
            elif curr_neuron_group.attrs['neuron_type'] == 'eye2':
                curr_neuron = Eye2.from_h5_group(curr_neuron_group)
            elif curr_neuron_group.attrs['neuron_type'] == 'muscle':
                curr_neuron = Muscle.from_h5_group(curr_neuron_group)
            else:
                raise LookupError('Brain: fail to load neuron. "neuron_type" attribute should be one of the '
                                  'following: "eye2", "neuron" or "muscle".')

            neurons.loc[curr_ind] = [curr_layer, curr_neuron_ind, curr_neuron]

        connections = {}

        connections_group = h5_group['connections']
        connections_names = connections_group.keys()
        connections_names.sort()
        for connections_name in connections_names:
            curr_conn_group = connections_group[connections_name]
            curr_inds = curr_conn_group.attrs['rows']
            curr_cols = curr_conn_group.attrs['cols']
            curr_amplitudes = curr_conn_group['amplitudes'].value
            curr_decay_times = curr_conn_group['decay_times_tu'].value
            curr_rise_times = curr_conn_group['rise_times_tu'].value
            curr_latencies = curr_conn_group['latencies_tu'].value

            curr_conn_df = pd.DataFrame(columns=curr_cols, index=curr_inds)

            for i in range(len(curr_inds)):
                for j in range(len(curr_cols)):
                    curr_conn_df.iloc[i, j] = Connection(latency=curr_latencies[i, j],
                                                         amplitude=curr_amplitudes[i, j],
                                                         rise_time=curr_rise_times[i, j],
                                                         decay_time=curr_decay_times[i, j])
            connections.update({connections_name: curr_conn_df})

        loaded_brain = Brain(neurons=neurons, connections=connections)

        return loaded_brain

    def generate_empty_action_histories(self):
        '''
        :return: a data frame with empty lists, each list is the action history of a particular neuron, in the same 
        order as self._neurons data frame, columns = ['action_history']
        '''

        # the following code is very bad, it synchronize all the lists in the data frame
        # empty_action_histories = pd.DataFrame(index=self._neurons.index)
        # empty_action_histories['action_history'] = [[]] * len(empty_action_histories)

        empty_action_histories = pd.Series([[] for i in range(len(self._neurons))])
        empty_action_histories = pd.DataFrame(empty_action_histories, columns=['action_history'])
        return empty_action_histories

    def generate_empty_psp_waveforms(self, simulation_length):
        '''
        :param simulation_length: int, number of time points of the simulation
        :return: 2d-array of zeros, float32, psp waveforms of all neurons in the brain, each row represents one
                 neuron in the same order as self._neurons data frame, each column represents a time point
        '''

        return np.zeros((len(self._neurons), simulation_length), dtype=np.float32)


if __name__ == '__main__':

    # =========================================================================================
    # dfile = h5py.File(r"F:\littlefish\test_folder\neuron_test.hdf5")
    # neuron_group = dfile.create_group('test_neuron')
    # neuron = Neuron()
    # for i in range(SIMULATION_LENGTH):
    #     neuron.act(i)
    # neuron.to_h5_group(neuron_group)
    # =========================================================================================

    # =========================================================================================
    # connection = Connection(amplitude=10, latency=5)
    # print(connection.get_psp())
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 50
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    # connection = Connection(amplitude=10, latency=5, rise_time=5, decay_time=10)
    # connection.act(2, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(4, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(40, postsynaptic_input)
    # print(postsynaptic_input)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 5000
    # neuron_pre = Neuron(baseline_rate=0.005)
    # neuron_post = Neuron(baseline_rate=0.000)
    # connection = Connection(amplitude=1, latency=5, rise_time=1, decay_time=1)
    #
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    #
    # for i in range(SIMULATION_LENGTH):
    #
    #     is_firing = neuron_pre.act(i)
    #     if is_firing:
    #         connection.act(i, postsynaptic_input)
    #     neuron_post.act(i, probability_input=postsynaptic_input[i])
    #
    # spk_train_pre = neuron_pre.get_action_history()
    # spk_train_post = neuron_post.get_action_history()
    #
    # # print(postsynaptic_input)
    # print(len(spk_train_pre))
    # print(len(spk_train_post))
    #
    # ccg, t = util.discreat_crosscorrelation(np.array(spk_train_pre), np.array(spk_train_post))
    # plt.bar(t, ccg)
    # plt.show()
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # terrain_map = np.zeros((5, 5), dtype=np.uint8)
    # terrain_map[3, 3] = 1
    # print(terrain_map)
    #
    # eye = Eye(position=(2, 3), direction='south')
    # print(eye._get_input(terrain_map=terrain_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(i, terrain_map=terrain_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 20000
    # muscle = Muscle(direction='east', baseline_rate=0., refractory_period=5000)
    # movements = []
    # for i in range(SIMULATION_LENGTH):
    #     movement=muscle.act(i, probability_input=0.5, probability_base=0.1)
    #     if movement:
    #         movements.append(movement)
    # print(movements)
    # print(muscle.get_action_history())
    # =========================================================================================

    # =========================================================================================
    # brain = Brain()
    # neurons_df = brain.generate_default_neurons_df()
    # connections_df = brain.generate_default_connections_df(neurons_df)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # terrain_map = np.zeros((5, 5), dtype=np.uint8)
    # terrain_map[3, 3] = 1
    # print(terrain_map)
    #
    # eye = Eye2(direction='south')
    # position = (2, 3)
    # print(eye._get_input_pixels(position=position, terrain_map=terrain_map))
    # print(eye._get_input(position=position, terrain_map=terrain_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(t_point=i, position=position, terrain_map=terrain_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # brain = Brain()
    # print(brain.has_action_histories())
    # brain._generate_empty_psp_waveforms()
    # print(brain.get_neuron_inds_in_layer(2))
    # print(brain.get_all_presynaptic_neuron_indices())
    # print(brain.get_all_postsynaptic_neuron_indices())
    # print(brain.get_eye_type(13))
    # print(brain.layer_num)
    # print(brain.get_postsynaptic_neuron_inds(8))
    # print(brain.get_presynaptic_neuron_inds(8))
    # print(brain.get_single_connection(8, 13))
    # print(brain.get_single_connection(8, 16))
    # print(brain.get_neuron_inds_in_layer(3))
    # #
    # test_file_path = r"F:\littlefish\test_folder\brain_test.hdf5"
    # if os.path.isfile(test_file_path):
    #     os.remove(test_file_path)
    # test_file = h5py.File(test_file_path)
    # brain_group = test_file.create_group('brain')
    # brain.to_h5_group(brain_group)
    # test_file.close()
    # =========================================================================================

    # =========================================================================================
    # test_file = h5py.File(r"F:\littlefish\test_folder\brain_test.hdf5")
    # brain = Brain.from_h5_group(test_file['brain'])
    # =========================================================================================

    # =========================================================================================
    # dfile = h5py.File(r"F:\littlefish\test_folder\brain_test.hdf5")
    # neuron = Neuron.from_h5_group(dfile['brain/neurons/neuron_00008'])
    # print(neuron.get_action_history())
    # =========================================================================================

    # =========================================================================================
    # bb = Brain()
    # print(bb)
    # print(len(bb.get_connections()))
    # print(bb.get_connections()['L000_L001'])
    # =========================================================================================

    # =========================================================================================
    # mb = Brain()
    # eah = mb.generate_empty_action_histories()
    # print eah

    # =========================================================================================
    min_brain = generate_minimal_brain()
    print min_brain._neurons
    # =========================================================================================

    print('debug...')
