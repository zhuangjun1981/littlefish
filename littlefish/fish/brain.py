# from __future__ import (absolute_import, division,
#                         print_function, unicode_literals)
# from builtins import *

import os
import sys
import random
import numpy as np
package_path, _ = os.path.split(os.path.dirname(os.path.realpath(__file__)))
sys.path.append(package_path)
import matplotlib.pyplot as plt
import utilities as util


# consider one time unit is 0.1 milisecond, time unit should be small enough that no more than one action is possible
# per time unit
SIMULATION_LENGTH = int(1e5)  # number of time units in simulation


class Neuron(object):
    """
    a very simple neuron class
    """

    def __init__(self, baseline_rate=0.0001, refractory_period=10):
        """
        action is the equivalent of action potential in biology, and consider one time unit is 0.1 milisecond

        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        self._baseline_rate = float(baseline_rate)
        self._refractory_period = float(refractory_period)
        self._action_history = []

    def get_baseline_rate(self):
        return self._baseline_rate

    def get_refractory_period(self):
        return self._refractory_period

    def get_action_history(self):
        """
        :return: action_history, list of ints, timing of all actions as indices in time axis of time unit
        """
        return self._action_history

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: bool, True: fire; False: quite
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise(ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                return True
            else:
                return False


class Eye(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron
    """

    def __init__(self, position, direction, input_filter=None, gain=None, baseline_rate=0., refractory_period=10):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 3 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        0 0 0 0 0 0 0
        0 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param position: the coordinate of the eye, tuple of two ints, (row, col)
        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        super(Eye, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

        if len(position) != 2:
            raise(ValueError, 'position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise(ValueError, 'Elements in position should both be integers.')

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = np.array([0.2, 0.6, 0.2])
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

    def move(self, movement):
        """
        update eye position

        :param movement: movement vector, tuple of two ints, (row, col)
        """
        if len(movement) != 2:
            raise(ValueError, 'Movement vector should have 2 elements.')

        if isinstance(movement[0], int) and isinstance(movement[1], int):
            self._position = (self._position[0] + movement[0],
                              self._position[1] + movement[1])
        else:
            raise(ValueError, 'Elements in movement should both be integers.')

    def _get_input_pixels(self, world_map, border_value=1.):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the world_map
        range will be returned as border_value
        """

        if len(world_map.shape) != 2:
            raise(ValueError, 'world_map should a 2-d array.')

        if self._direction == 'east':
            ind = [[self._position[0] + 1, self._position[1] + 1],
                   [self._position[0],     self._position[1] + 1],
                   [self._position[0] - 1, self._position[1] + 1]]
        elif self._direction == 'northeast':
            ind = [[self._position[0],     self._position[1] + 1],
                   [self._position[0] - 1, self._position[1] + 1],
                   [self._position[0] - 1, self._position[1]]]
        elif self._direction == 'north':
            ind = [[self._position[0] - 1, self._position[1] + 1],
                   [self._position[0] - 1, self._position[1]],
                   [self._position[0] - 1, self._position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[self._position[0] - 1, self._position[1]],
                   [self._position[0] - 1, self._position[1] - 1],
                   [self._position[0],     self._position[1] - 1]]
        elif self._direction == 'west':
            ind = [[self._position[0] - 1, self._position[1] - 1],
                   [self._position[0],     self._position[1] - 1],
                   [self._position[0] + 1, self._position[1] - 1]]
        elif self._direction == 'southwest':
            ind = [[self._position[0],     self._position[1] - 1],
                   [self._position[0] + 1, self._position[1] - 1],
                   [self._position[0] + 1, self._position[1]]]
        elif self._direction == 'south':
            ind = [[self._position[0] + 1, self._position[1] - 1],
                   [self._position[0] + 1, self._position[1]],
                   [self._position[0] + 1, self._position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[self._position[0] + 1, self._position[1]],
                   [self._position[0] + 1, self._position[1] + 1],
                   [self._position[0],     self._position[1] + 1]]
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] > world_map.shape[0] or cor[1] < 0 or cor[1] > world_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(world_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, **kwargs):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(**kwargs)
        probablity_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probablity_input

    def act(self, t_point, **kwargs):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param kwargs, border_value trace back to self._get_input_pixels
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(**kwargs)

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if random.random() <= curr_rate:
                self._action_history.append(t_point)
                return True
            else:
                return False


class Muscle(Neuron):
    """
    muscle class for determining the motion of the fish. Subclass of Neuron class
    """

    def __init__(self, direction, baseline_rate=0.0001, refractory_period=5000):

        if direction in ['east', 'north', 'west', 'south']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['east', 'north', 'west', 'south'].")

        super(Muscle, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the muscle will try to move the fish or not
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: no attempt: False
                 attempt: movement vector, tuple of two ints
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise (ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                if self._direction == 'east':
                    return (0, 1)
                elif self._direction == 'north':
                    return (-1, 0)
                elif self._direction == 'west':
                    return (0, -1)
                elif self._direction == 'south':
                    return (1, 0)
                else:
                    raise(ValueError, "self.direction should be one of the following: "
                                      "['east', 'north', 'west', 'south'].")
            else:
                return False


class Connection(object):
    """
    synaptic connection between two neurons
    """

    def __init__(self, latency=30, amplitude=0.0001, rise_time=5, decay_time=10):
        """

        :param latency: int, temporal latency from presynaptic neuron action to the postsynaptic effect onset, number
                        of time units
        :param amplitude: float, peak change of the firing rate in the postsynaptic neuron, probablity of a action per
                          time unit. can be positive (excitatiory) or negative (inhibitory)
        :param rise_time: int, temporal duration from onset to peak, number of time units
        :param decay_time: int, temporal duration from peak to baseline, number of time units
        """

        self._latency = latency
        self._amplitude = amplitude
        self._rise_time = rise_time
        self._decay_time = decay_time

        self._generate_psp()

    def _generate_psp(self):
        """
        generate post synaptic probability wave form
        """

        self._psp = np.zeros(self._latency + self._rise_time + self._decay_time)
        self._psp[self._latency: self._latency + self._rise_time] = self._amplitude * \
            (np.arange(self._rise_time, dtype=np.float32) + 1) / self._rise_time
        self._psp[-self._decay_time:] = self._amplitude * \
            (np.arange(self._decay_time, 0, -1, dtype=np.float32) - 1) / self._decay_time

    def get_psp(self):
        return self._psp

    def act(self, time_point, postsynaptic_input):
        """
        if the presynaptic neuron fires at the 'time_point', a psp wave form will be generated and add to the
        input array of the postsynaptic neuron
        :param time_point: int, current time point as the index of time unit axis
        :param postsynaptic_input: 1-d array of floats
        :return:
        """
        psp_end = time_point + len(self._psp)
        if psp_end <= len(postsynaptic_input):
            postsynaptic_input[time_point: psp_end] += self._psp
        else:
            postsynaptic_input[time_point:] += self._psp[:len(postsynaptic_input)-time_point]


# class Muscle(object):
#     """
#     muscle class for determining the motion of the fish
#     """
#
#     def __init__(self, threshold=10, integration_window=5000, refractory_period=10000):
#         """
#         :param threshold: int, if the number of actions detected in the integration_window is larger than this
#                           threshold, the muscle will try to excert movement
#         :param integration_window: int, the window duration in time unit the muscle integrates the inputs
#         :param refractory_period: int, the period in time unit that the muscle could not act after previous movement
#         """
#
#         self._threshold = int(threshold)
#         self._integration_window = int(integration_window)
#         self._refractory_period = int(refractory_period)
#         self._movement_history = []  # list of indices of action timestamps, list of ints
#         self._detected_actions = []  # list of input action timestamps within the integration window, list of ints
#
#     def get_movement_history(self):
#         """
#         return list of indices of movment timestamps, list of ints
#         note: this only record the attempts of movement, does not necessarily reflect the actual movement. i.e. the
#         attempts to move out of the terrain map will fail but the attempts will be saved in this variable
#         """
#         return self._movement_history
#
#     def _clear(self):
#         self._detected_actions = []
#
#     def move(self, t_point, action_input):
#         """
#
#         :param t_point: int, current timestamp in time unit axis
#         :param action_input: int, number of presynaptic input actions at this given time point
#         :return: True, if the muscle attempts to move
#                  False, if the muscle decides not to move
#         """
#
#         if not isinstance(action_input, int):
#             raise(ValueError, 'input should be an integer.')
#
#         # add inputs to self._detected_actions
#         self._detected_actions += [t_point] * action_input
#
#         # remove action in self._detected_actions outside the integration_window
#         self._detected_actions = [a for a in self._detected_actions if (t_point - a < self._integration_window)]
#
#         if len(self._movement_history) > 0 and t_point - self._movement_history[-1] < self._refractory_period:
#             # if current time is within the refractory period from last action
#             return False
#         else:
#             if len(self._detected_actions) >= self._threshold:
#                 self._clear()
#                 self._movement_history.append(t_point)
#                 return True
#             else:
#                 return False


if __name__ == '__main__':

    # =========================================================================================
    # neuron = Neuron()
    # for i in range(SIMULATION_LENGTH):
    #     neuron.act(i)
    # print(len(neuron.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # connection = Connection(amplitude=10, latency=5)
    # print(connection.get_psp())
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 50
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    # connection = Connection(amplitude=10, latency=5, rise_time=5, decay_time=10)
    # connection.act(2, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(4, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(40, postsynaptic_input)
    # print(postsynaptic_input)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 5000
    # neuron_pre = Neuron(baseline_rate=0.005)
    # neuron_post = Neuron(baseline_rate=0.000)
    # connection = Connection(amplitude=1, latency=5, rise_time=1, decay_time=1)
    #
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    #
    # for i in range(SIMULATION_LENGTH):
    #
    #     is_firing = neuron_pre.act(i)
    #     if is_firing:
    #         connection.act(i, postsynaptic_input)
    #     neuron_post.act(i, probability_input=postsynaptic_input[i])
    #
    # spk_train_pre = neuron_pre.get_action_history()
    # spk_train_post = neuron_post.get_action_history()
    #
    # # print(postsynaptic_input)
    # print(len(spk_train_pre))
    # print(len(spk_train_post))
    #
    # ccg, t = util.discreat_crosscorrelation(np.array(spk_train_pre), np.array(spk_train_post))
    # plt.bar(t, ccg)
    # plt.show()
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # world_map = np.zeros((5, 5), dtype=np.uint8)
    # world_map[3, 3] = 1
    # print(world_map)
    #
    # eye = Eye(position=(2, 3), direction='south')
    # print(eye._get_input(world_map=world_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(i, world_map=world_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    SIMULATION_LENGTH = 20000
    muscle = Muscle(direction='east', baseline_rate=0., refractory_period=5000)
    movements = []
    for i in range(SIMULATION_LENGTH):
        movement=muscle.act(i, probability_input=0.5, probability_base=0.1)
        if movement:
            movements.append(movement)
    print(movements)
    print(muscle.get_action_history())
    # =========================================================================================

    print('debug...')
