# from __future__ import (absolute_import, division,
#                         print_function, unicode_literals)
# from builtins import *

import os
import sys
import random
import numpy as np
import pandas as pd
package_path, _ = os.path.split(os.path.dirname(os.path.realpath(__file__)))
sys.path.append(package_path)
import matplotlib.pyplot as plt
import utilities as util


# consider one time unit is 0.1 milisecond, time unit should be small enough that no more than one action is possible
# per time unit
SIMULATION_LENGTH = int(1e5)  # number of time units in simulation

EYE_GAIN = 0.001
EYE_BASELINE_RATE = 0.
EYE_REFRACTORY_PERIOD = 10
EYE_BORDER_VALUE = 1
EYE_INPUT_FILTER = np.array([0.2, 0.6, 0.2])
EYE2_INPUT_FILTER = np.array([0.15, 0.3, 0.15, 0.1, 0.2, 0.1])
EYE_DIRECTIONS = ['east', 'northeast', 'north', 'northwest', 'west', 'southwest', 'south', 'southeast']

NEURON_REFRACTORY_PERIOD = 10
NEURON_BASELINE_RATE = 0.0001

MUSCLE_DIRECTIONS = ['east', 'north', 'west', 'south']
MUSCLE_REFRACTORY_PERIOD = 5000
MUSCLE_BASELINE_RATE = 0.00001

CONNECTION_LATENCY = 30
CONNECTION_AMPLITUDE = 0.0001
CONNECTION_RISE_TIME = 5
CONNECTION_DECAY_TIME = 10


class Neuron(object):
    """
    a very simple neuron class
    """

    def __init__(self, baseline_rate=NEURON_BASELINE_RATE, refractory_period=NEURON_REFRACTORY_PERIOD):
        """
        action is the equivalent of action potential in biology, and consider one time unit is 0.1 milisecond

        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        self._baseline_rate = float(baseline_rate)
        self._refractory_period = float(refractory_period)
        self._action_history = []

    def get_baseline_rate(self):
        return self._baseline_rate

    def get_refractory_period(self):
        return self._refractory_period

    def get_action_history(self):
        """
        :return: action_history, list of ints, timing of all actions as indices in time axis of time unit
        """
        return self._action_history

    def reset_action_history(self):
        self._action_history = []

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: bool, True: fire; False: quite
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise(ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                return True
            else:
                return False


class Eye(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 1 pixel
    """

    def __init__(self, direction, input_filter=EYE_INPUT_FILTER, gain=EYE_GAIN,
                 baseline_rate=EYE_BASELINE_RATE, refractory_period=EYE_REFRACTORY_PERIOD):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 3 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        0 0 0 0 0 0 0
        0 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        super(Eye, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        self._input_filter = input_filter.astype(np.float)

        self._gain = float(gain)

    def _get_input_pixels(self, world_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the world_map
        range will be returned as border_value
        """
        
        if len(position) != 2:
            raise(ValueError, 'position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise(ValueError, 'Elements in position should both be integers.')

        if len(world_map.shape) != 2:
            raise(ValueError, 'world_map should a 2-d array.')
        
        if position[0] < 0 or position[0] >= world_map.shape[0] or \
                position[1] < 0 or position[1] >= world_map.shape[1]:
            raise(ValueError, 'position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1]]
        elif self._direction == 'northeast':
            ind = [[position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1]]
        elif self._direction == 'southwest':
            ind = [[position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1]]
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= world_map.shape[0] or cor[1] < 0 or cor[1] >= world_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(world_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, **kwargs):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(**kwargs)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def act(self, t_point, **kwargs):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param world_map: binary 2-d map, for now it should only contain 0s and 1s
        :param border_value: int, default 1, value for pixels outside the world_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(**kwargs)

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if random.random() <= curr_rate:
                self._action_history.append(t_point)
                return True
            else:
                return False


class Eye2(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 2 pixels
    """

    def __init__(self, direction, input_filter=EYE2_INPUT_FILTER, gain=EYE_GAIN, baseline_rate=EYE_BASELINE_RATE,
                 refractory_period=EYE_REFRACTORY_PERIOD):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 6 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        3 3 0 0 0 0 0
        3 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        super(Eye2, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = EYE2_INPUT_FILTER
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

    def _get_input_pixels(self, world_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the world_map
        range will be returned as border_value
        """

        if len(position) != 2:
            raise (ValueError, 'position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise (ValueError, 'Elements in position should both be integers.')

        if len(world_map.shape) != 2:
            raise (ValueError, 'world_map should a 2-d array.')

        if position[0] < 0 or position[0] >= world_map.shape[0] or \
                position[1] < 0 or position[1] >= world_map.shape[1]:
            raise (ValueError, 'position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] + 1, position[1] + 2],
                   [position[0], position[1] + 2],
                   [position[0] - 1, position[1] + 2]]
        elif self._direction == 'northeast':
            ind = [[position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] + 2],
                   [position[0] - 2, position[1] + 2],
                   [position[0] - 2, position[1] + 1]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0] - 2, position[1] + 1],
                   [position[0] - 2, position[1]],
                   [position[0] - 2, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] - 2, position[1] - 1],
                   [position[0] - 2, position[1] - 2],
                   [position[0] - 1, position[1] - 2]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] - 1, position[1] - 2],
                   [position[0], position[1] - 2],
                   [position[0] + 1, position[1] - 2]]
        elif self._direction == 'southwest':
            ind = [[position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] - 2],
                   [position[0] + 2, position[1] - 2],
                   [position[0] + 2, position[1] - 2]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0] + 2, position[1] - 1],
                   [position[0] + 2, position[1]],
                   [position[0] + 2, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] + 2, position[1] + 1],
                   [position[0] + 2, position[1] + 2],
                   [position[0] + 1, position[1] + 2]
                   ]
        else:
            raise (ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= world_map.shape[0] or cor[1] < 0 or cor[1] >= world_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(world_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, **kwargs):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(**kwargs)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def act(self, t_point, **kwargs):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param world_map: binary 2-d map, for now it should only contain 0s and 1s
        :param border_value: int, default 1, value for pixels outside the world_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(**kwargs)

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if random.random() <= curr_rate:
                self._action_history.append(t_point)
                return True
            else:
                return False


class Muscle(Neuron):
    """
    muscle class for determining the motion of the fish. Subclass of Neuron class
    """

    def __init__(self, direction, baseline_rate=MUSCLE_BASELINE_RATE, refractory_period=MUSCLE_REFRACTORY_PERIOD):

        if direction in ['east', 'north', 'west', 'south']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['east', 'north', 'west', 'south'].")

        super(Muscle, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the muscle will try to move the fish or not
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: no attempt: False
                 attempt: movement vector, tuple of two ints
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise (ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                if self._direction == 'east':
                    return 0, 1
                elif self._direction == 'north':
                    return -1, 0
                elif self._direction == 'west':
                    return 0, -1
                elif self._direction == 'south':
                    return 1, 0
                else:
                    raise(ValueError, "self.direction should be one of the following: "
                                      "['east', 'north', 'west', 'south'].")
            else:
                return False


class Connection(object):
    """
    synaptic connection between two neurons
    """

    def __init__(self, latency=CONNECTION_LATENCY, amplitude=CONNECTION_AMPLITUDE, rise_time=CONNECTION_RISE_TIME,
                 decay_time=CONNECTION_DECAY_TIME):
        """

        :param latency: int, temporal latency from presynaptic neuron action to the postsynaptic effect onset, number
                        of time units
        :param amplitude: float, peak change of the firing rate in the postsynaptic neuron, probablity of a action per
                          time unit. can be positive (excitatiory) or negative (inhibitory)
        :param rise_time: int, temporal duration from onset to peak, number of time units
        :param decay_time: int, temporal duration from peak to baseline, number of time units
        """

        if latency is not None:
            if not isinstance(latency, int):
                raise (ValueError, 'latency should be an integer.')
            self._latency = latency

        if amplitude is not None:
            self._amplitude = float(amplitude)

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise (ValueError, 'rise_time should be an integer.')
            self._rise_time = rise_time

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise (ValueError, 'decay_time should be an integer.')
            self._decay_time = decay_time

        self._generate_psp()

    def _generate_psp(self):
        """
        generate post synaptic probability wave form
        """

        self._psp = np.zeros(self._latency + self._rise_time + self._decay_time)
        self._psp[self._latency: self._latency + self._rise_time] = self._amplitude * \
            (np.arange(self._rise_time) + 1).astype(np.float32) / float(self._rise_time)
        self._psp[-self._decay_time:] = self._amplitude * \
            (np.arange(self._decay_time, 0, -1) - 1).astype(np.float32) / float(self._decay_time)

    def get_psp(self):
        return self._psp

    def set_params(self, latency=None, amplitude=None, rise_time=None, decay_time=None):
        """
        set new parameters and regenerate psp waveform

        :param latency: int, number of time units for time delay
        :param amplitude: float, peak probability
        :param rise_time: int, number of time units to rise to peak
        :param decay_time: int, number of time units to decay to baseline
        """

        changed = False

        if latency is not None:
            if not isinstance(latency, int):
                raise (ValueError, 'latency should be an integer.')
            self._latency = latency
            changed = True

        if amplitude is not None:
            self._amplitude = float(amplitude)
            changed = True

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise (ValueError, 'rise_time should be an integer.')
            self._rise_time = rise_time
            changed = True

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise (ValueError, 'decay_time should be an integer.')
            self._decay_time = decay_time
            changed = True

        if changed:
            self._generate_psp()
        else:
            print('Brain.Connection: no parameter has been changed. Do nothing.')

    def act(self, time_point, postsynaptic_input):
        """
        if the presynaptic neuron fires at the 'time_point', a psp wave form will be generated and add to the
        input array of the postsynaptic neuron
        :param time_point: int, current time point as the index of time unit axis
        :param postsynaptic_input: 1-d array of floats
        :return:
        """
        psp_end = time_point + len(self._psp)
        if psp_end <= len(postsynaptic_input):
            postsynaptic_input[time_point: psp_end] += self._psp
        else:
            postsynaptic_input[time_point:] += self._psp[:len(postsynaptic_input)-time_point]


class Brain(object):
    """
    brain class, the neural network from eye to muscle

    a 'brain' has a couple of sets of 8 eyes (brain.Eye object, each at each border pixel of the body). each set of
    eyes are receiving inputs from different objects. i.e. one set of eyes will look at land/water, another set of eyes
    will look for food, another set of eyes will look for other fish.

    a 'brain' has 4 invisible muscles (brain.Muscle object, each controlling the movement in each direction).

    between eyes and muscles are a neural network consists of neurons (brain.Neuron object) and connections
    (brain.Connections object). Number of layers and number of neurons can be specified.
    """

    def __init__(self, neurons_df=None, connections_df=None):
        """

        :param neurons_df:
        :param connections_df:
        """

        if neurons_df is None:
            neurons_df = self.generate_default_neurons_df()
            self._generate_neurons(neurons_df)
        else:
            self._generate_neurons(neurons_df)

        if connections_df is None:
            self._generate_connections(self.generate_default_connections_df(neurons_df))
        else:
            self._generate_connections(connections_df)

        self._generate_connection_map()

        self._psp_waveforms = None

        self.check_integrity()

    def _generate_neurons(self, neurons_df, verbose_level=1):
        """
        generate a dataframe containing actual Neuron objects from a dataframe containing neuron parameters.
        assign it to self._neurons
        """

        self._neurons = pd.DataFrame(columns=['layer', 'type', 'neuron_id', 'neuron'])

        for i, row in neurons_df.iterrows():
            if 'baseline_rate' not in neurons_df.columns.values.tolist():
                baseline_rate = NEURON_BASELINE_RATE
            else:
                baseline_rate = row.baseline_rate

            if 'refractory_period' not in neurons_df.columns.values.tolist():
                refractory_period = NEURON_REFRACTORY_PERIOD
            else:
                refractory_period = row.refractory_period

            self._neurons.loc[i] = [row.layer, row.type, row.neuron_id, Neuron(baseline_rate, refractory_period)]

        self._neurons['layer'] = self._neurons['layer'].astype(np.uint32)
        self._neurons['neuron_id'] = self._neurons['neuron_id'].astype(np.uint32)

        if verbose_level == 0:
            print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.\n')
        elif verbose_level == 1:
            print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.')
            layer_num = max(self._neurons['layer']) + 1
            for layer in range(layer_num):
                layer_name = self.get_layer_name(layer, layer_num)
                neuron_num = len(self._neurons[self._neurons.layer == layer])
                print(layer_name + ' : ' + str(neuron_num) + ' neurons.')
        elif verbose_level == 2:
            print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.')
            print(self._neurons)
            print('\n')

    def _generate_connections(self, connections_df, verbose_level=0):
        """
        generate a dataframe containing actual Connection objects from a dataframe containing connection parameters.
        assign it to self._connections
        """
        self._connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'connection'])
        for i, row in connections_df.iterrows():

            if 'latency' not in connections_df.columns.values.tolist():
                latency = CONNECTION_LATENCY
            else:
                latency = int(row.latency)

            if 'amplitude' not in connections_df.columns.values.tolist():
                amplitude = CONNECTION_AMPLITUDE
            else:
                amplitude = float(row.amplitude)

            if 'rise_time' not in connections_df.columns.values.tolist():
                rise_time = CONNECTION_RISE_TIME
            else:
                rise_time = int(row.rise_time)

            if 'decay_time' not in connections_df.columns.values.tolist():
                decay_time = CONNECTION_DECAY_TIME
            else:
                decay_time = int(row.decay_time)

            self._connections.loc[i] = [row.presynaptic_ind, row.postsynaptic_ind,
                                        Connection(latency, amplitude, rise_time, decay_time)]

        self._connections['presynaptic_ind'] = self._connections['presynaptic_ind'].astype(np.uint32)
        self._connections['postsynaptic_ind'] = self._connections['postsynaptic_ind'].astype(np.uint32)

        if verbose_level == 0:
            print('\nBrain: self._connections dataframe with ' + str(len(self._connections)) +
                  ' neurons has been generated.')
        if verbose_level == 1:
            print('\nBrain: self._connections dataframe with ' + str(len(self._connections)) +
                  ' neurons has been generated.')
            print(self._connections)

    def get_neurons(self):
        return self._neurons

    def get_connections(self):
        return self._connections

    def has_action_histories(self):
        for neuron in self._neurons['neuron']:
            if len(neuron.get_action_history()) > 0:
                return True
        return False

    def has_psp_waveforms(self):
        if self._psp_waveforms is not None:
            return True
        else:
            return False

    def _generate_empty_psp_waveforms(self):
        if self.has_psp_waveforms():
            raise (ValueError, 'Brain: can not generate empty psp waveforms, psp waveforms already exist.')

        self._psp_waveforms = {}

        waveform_count = 0
        for i in range(len(self._neurons)):
            if self._neurons.loc[i, 'layer'] > 0:
                self._psp_waveforms.update({i: np.zeros(SIMULATION_LENGTH, dtype=np.float32)})

        print('\nBrain: empty psp waveforms created. number of waveforms: ' + str(len(self._psp_waveforms)) + '; length '
              'of waveforms: ' + str(SIMULATION_LENGTH) + ' time units.')

    def _generate_connection_map(self):
        """
        map from presynaptic neuron index to (connection index, postsynaptic neuron index) pair

        :return dictionary,
        {presynaptic neuron ind in self._neurons: a list of tuple (connection index,
                                                                   postsynaptic neuron index in self._neurons)}

         this dictionary will be stalled as self._connection_map

         the information in self._connection_map is redundant given self._neurons and self._connections.
         But with this generated once and installed in memory, the simulation can be much faster (hopefully)
        """
        self._connection_map = {}

        presynaptic_indices = np.unique(self._connections.loc[:, 'presynaptic_ind'])

        for presynaptic_ind in presynaptic_indices:
            postsynaptic_pairs = []
            for j in range(len(self._connections)):
                if self._connections.loc[j, 'presynaptic_ind'] == presynaptic_ind:
                    postsynaptic_pairs.append((j, self._connections.loc[j, 'postsynaptic_ind']))
            self._connection_map.update({presynaptic_ind: postsynaptic_pairs})

        print('\nBrain: connection map generated.')
        # print self._connection_map

    def check_integrity(self):
        """
        check integrity of object data structure
        """

        # todo: check self._neurons['layer'] is in increasing order; check self._neurons['neuron_id'] is in increasing
        # order within layers; check connections in self._connections are truely pre-post synaptic pairs, check
        # self._connections['presynaptic_ind'] is in increasing order; check self._connection_map represent real
        # connections; if self._psp_waveforms is not None, check self._psp_waveform.keys() represent postsynaptic
        # neuron indices in self._neurons

        pass

    def act(self, t_point, body_position, world_map, food_map=None):
        """
        :param t_point: int, current time stamp of time unit axis
        :param body_position: tuple of two ints, (row, col), current position of body center of the fish
        :param world_map: 2d array, with only 0s (water) and 1s (land). represents the land scape of the world
        :param food_map: 2d array, with only 0s (no food) and 1s (food). represents the distribution of food
        :return: movement attemps: tuple of 2 ints, represting the movement attempt, be careful, this may not
                                   represent the actual movement, it will be evaluated by the fish object (fish class)
                                   containing this brain to see if the movement is possible. if the fish is hitting
                                   the edge the world map, then the it will not move out of the map
                                   None: no movement has been attempted,
        """
        if len(body_position) != 2:
            raise (ValueError, 'body_position should contain two elements.')

        if (not isinstance(body_position[0], int)) or (not isinstance(body_position[1], int)):
            raise (ValueError, 'body_position should contain two integers.')

        if len(world_map.shape) != 2:
            raise(ValueError, 'world_map should be a 2-d array.')

        if not np.issubdtype(world_map.dtype, np.integer):
            raise(ValueError, 'dtype of world_map should be integer.')

        if np.max(world_map) > 1 or np.min(world_map) < 0:
            raise(ValueError, 'world_map should only contain 0s and 1s.')

        if body_position[0] < 1 or body_position[0] > world_map.shape[0] - 2 or \
            body_position[1] < 1 or body_position[1] > world_map.shape[1] - 2:
            raise(ValueError, 'body_position out of the range.')

        if not self.has_psp_waveforms():
            self._generate_empty_psp_waveforms()

        self.check_integrity()

        # todo: finish this method.


    def _clear_psp_waveforms(self):
        if self.has_psp_waveforms():
            self._psp_waveforms = None
            print('Brain: all psp waveforms deleted.')
        else:
            print('Brain: no psp waveforms found. Do nothing.')

    def _clear_action_histories(self):
        if self.has_action_histories():
            for neuron in self._neurons['neuron']:
                neuron.reset_action_history([])
            print('Brain: action histories of all neurons have been deleted.')
        else:
            print('Brain: no action history is found for any neuron. Do nothing.')

    def clear_simulation_data(self):
        self._clear_psp_waveforms()
        self._clear_action_histories()

    def to_h5_group(self):
        pass

    @staticmethod
    def from_h5_group(h5_group):
        pass

    @staticmethod
    def get_layer_name(layer_ind, layer_num):
        """
        return name of a layer given the total number of layers and index of the layer
        """
        if layer_num < 3:
            raise(ValueError, 'layer_num should be no less than 3.')

        if layer_ind == 0:
            layer_name = 'eye layer'
        elif layer_ind == layer_num - 1:
            layer_name = 'muscle layer'
        else:
            layer_name = 'hidden layer ' + util.int2str(layer_ind, 2)
        return layer_name
    
    @staticmethod
    def generate_default_neurons_df():
        """
        generate and return a dataframe containing all neurons with default parameters
        """
        neurons = pd.DataFrame(columns=['layer', 'type', 'neuron_id', 'baseline_rate', 'refractory_period'])

        ind = 0
        for i in range(8):
            neurons.loc[ind] = [0, 'eye_terrain', i, EYE_BASELINE_RATE, EYE_REFRACTORY_PERIOD]
            ind += 1

        for i in range(8):
            neurons.loc[ind] = [1, 'hidden_001', i, NEURON_BASELINE_RATE, NEURON_REFRACTORY_PERIOD]
            ind += 1

        for i in range(4):
            neurons.loc[ind] = [2, 'muscle', i, MUSCLE_BASELINE_RATE, MUSCLE_REFRACTORY_PERIOD]
            ind += 1

        neurons['layer'] = neurons['layer'].astype(np.uint32)
        neurons['neuron_id'] = neurons['neuron_id'].astype(np.uint32)
        neurons['baseline_rate'] = neurons['baseline_rate'].astype(np.float64)
        neurons['refractory_period'] = neurons['refractory_period'].astype(np.uint64)

        return neurons

    @staticmethod
    def generate_default_connections_df(neurons_df):
        """
        from a dataframe containing parameters of all neurons, generate and return a dataframe containing all
        connections with default parameters
        """
        layer_num = np.max(neurons_df['layer']) + 1

        connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'latency', 'amplitude',
                                            'rise_time', 'decay_time'])

        ind = 0
        for i in range(len(neurons_df)):
            curr_presynaptic_layer = neurons_df.loc[i,'layer']
            if curr_presynaptic_layer < layer_num - 1:
                for j in range(len(neurons_df)):
                    if neurons_df.loc[j, 'layer'] == curr_presynaptic_layer + 1:
                        connections.loc[ind] = [i, j, CONNECTION_LATENCY, CONNECTION_AMPLITUDE, CONNECTION_RISE_TIME,
                                                CONNECTION_DECAY_TIME]
                        ind += 1

        connections['presynaptic_ind'] = connections['presynaptic_ind'].astype(np.uint32)
        connections['postsynaptic_ind'] = connections['postsynaptic_ind'].astype(np.uint32)

        return connections


if __name__ == '__main__':

    # =========================================================================================
    # neuron = Neuron()
    # for i in range(SIMULATION_LENGTH):
    #     neuron.act(i)
    # print(len(neuron.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # connection = Connection(amplitude=10, latency=5)
    # print(connection.get_psp())
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 50
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    # connection = Connection(amplitude=10, latency=5, rise_time=5, decay_time=10)
    # connection.act(2, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(4, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(40, postsynaptic_input)
    # print(postsynaptic_input)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 5000
    # neuron_pre = Neuron(baseline_rate=0.005)
    # neuron_post = Neuron(baseline_rate=0.000)
    # connection = Connection(amplitude=1, latency=5, rise_time=1, decay_time=1)
    #
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    #
    # for i in range(SIMULATION_LENGTH):
    #
    #     is_firing = neuron_pre.act(i)
    #     if is_firing:
    #         connection.act(i, postsynaptic_input)
    #     neuron_post.act(i, probability_input=postsynaptic_input[i])
    #
    # spk_train_pre = neuron_pre.get_action_history()
    # spk_train_post = neuron_post.get_action_history()
    #
    # # print(postsynaptic_input)
    # print(len(spk_train_pre))
    # print(len(spk_train_post))
    #
    # ccg, t = util.discreat_crosscorrelation(np.array(spk_train_pre), np.array(spk_train_post))
    # plt.bar(t, ccg)
    # plt.show()
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # world_map = np.zeros((5, 5), dtype=np.uint8)
    # world_map[3, 3] = 1
    # print(world_map)
    #
    # eye = Eye(position=(2, 3), direction='south')
    # print(eye._get_input(world_map=world_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(i, world_map=world_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 20000
    # muscle = Muscle(direction='east', baseline_rate=0., refractory_period=5000)
    # movements = []
    # for i in range(SIMULATION_LENGTH):
    #     movement=muscle.act(i, probability_input=0.5, probability_base=0.1)
    #     if movement:
    #         movements.append(movement)
    # print(movements)
    # print(muscle.get_action_history())
    # =========================================================================================

    # =========================================================================================
    # brain = Brain()
    # neurons_df = brain.generate_default_neurons_df()
    # connections_df = brain.generate_default_connections_df(neurons_df)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # world_map = np.zeros((5, 5), dtype=np.uint8)
    # world_map[3, 3] = 1
    # print(world_map)
    #
    # eye = Eye2(direction='south')
    # position = (2, 3)
    # print(eye._get_input_pixels(position=position, world_map=world_map))
    # print(eye._get_input(position=position, world_map=world_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(t_point=i, position=position, world_map=world_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    brain = Brain()
    # print(brain.has_action_histories())
    brain._generate_empty_psp_waveforms()
    # =========================================================================================

    print('debug...')
