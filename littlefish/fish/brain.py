# from __future__ import (absolute_import, division,
#                         print_function, unicode_literals)
# from builtins import *

import os
import sys
import random
import numpy as np
import pandas as pd
package_path, _ = os.path.split(os.path.dirname(os.path.realpath(__file__)))
sys.path.append(package_path)
import matplotlib.pyplot as plt
import littlefish.utilities as util


# consider one time unit is 0.1 milisecond, time unit should be small enough that no more than one action is possible
# per time unit
SIMULATION_LENGTH = int(1e5)  # number of time units in simulation

EYE_GAIN = 0.005
EYE_BASELINE_RATE = 0.
EYE_REFRACTORY_PERIOD = 10
EYE_BORDER_VALUE = 1
EYE_INPUT_FILTER = np.array([0.2, 0.6, 0.2])
EYE2_INPUT_FILTER = np.array([0.15, 0.3, 0.15, 0.1, 0.2, 0.1])
EYE_DIRECTIONS = ['east', 'northeast', 'north', 'northwest', 'west', 'southwest', 'south', 'southeast']
EYE_INPUT_TYPES = ['terrain', 'food', 'fish']

NEURON_REFRACTORY_PERIOD = 10
NEURON_BASELINE_RATE = 0.0001

MUSCLE_DIRECTIONS = ['east', 'north', 'west', 'south']
MUSCLE_REFRACTORY_PERIOD = 5000
MUSCLE_BASELINE_RATE = 0.00001

CONNECTION_LATENCY = 30
CONNECTION_AMPLITUDE = 0.0001
CONNECTION_RISE_TIME = 50
CONNECTION_DECAY_TIME = 100


class Neuron(object):
    """
    a very simple neuron class
    """

    def __init__(self, baseline_rate=NEURON_BASELINE_RATE, refractory_period=NEURON_REFRACTORY_PERIOD):
        """
        action is the equivalent of action potential in biology, and consider one time unit is 0.1 milisecond

        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        """

        self._baseline_rate = float(baseline_rate)
        self._refractory_period = float(refractory_period)
        self._action_history = []

    def __str__(self):
        return 'littlefish.brain.Neuron object'

    def get_baseline_rate(self):
        return self._baseline_rate

    def get_refractory_period(self):
        return self._refractory_period

    def get_action_history(self):
        """
        :return: action_history, list of ints, timing of all actions as indices in time axis of time unit
        """
        return self._action_history

    def reset_action_history(self):
        self._action_history = []

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: bool, True: fire; False: quite
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise(ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                return True
            else:
                return False


class Eye(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 1 pixel
    """

    def __init__(self, direction, input_filter=None, gain=None, input_type=None, baseline_rate=None,
                 refractory_period=None):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 3 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        0 0 0 0 0 0 0
        0 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        :param input_type: str, type of the input the eye receives, should be one of 'terrain', 'food', 'fish',
               default: 'terrain'
        """

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise (ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = EYE_INPUT_FILTER
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

        if input_type is None:
            self._input_type = 'terrain'
        elif input_type in ['terrain', 'food', 'fish']:
            self._input_type = input_type
        else:
            raise (ValueError, 'Eye2: type should be one of the following: "terrain", "food", "fish".')

        if baseline_rate is None:
            curr_baseline_rate = EYE_BASELINE_RATE
        else:
            curr_baseline_rate = float(baseline_rate)

        if refractory_period is None:
            curr_refractory_period = EYE_REFRACTORY_PERIOD
        else:
            curr_refractory_period = int(refractory_period)

        super(Eye, self).__init__(baseline_rate=curr_baseline_rate, refractory_period=curr_refractory_period)

    def __str__(self):
        return 'littlefish.brain.Eye object'

    def _get_input_pixels(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the terrain_map
        range will be returned as border_value
        """
        
        if len(position) != 2:
            raise(ValueError, 'position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise(ValueError, 'Elements in position should both be integers.')

        if len(input_map.shape) != 2:
            raise(ValueError, 'terrain_map should a 2-d array.')
        
        if position[0] < 0 or position[0] >= input_map.shape[0] or \
                position[1] < 0 or position[1] >= input_map.shape[1]:
            raise(ValueError, 'position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1]]
        elif self._direction == 'northeast':
            ind = [[position[0],     position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1]]
        elif self._direction == 'southwest':
            ind = [[position[0],     position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0],     position[1] + 1]]
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= input_map.shape[0] or cor[1] < 0 or cor[1] >= input_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(input_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(input_map, position, border_value=EYE_BORDER_VALUE)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def act(self, t_point, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param terrain_map: binary 2-d map, for now it should only contain 0s and 1s
        :param border_value: int, default 1, value for pixels outside the terrain_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(input_map, position, border_value=EYE_BORDER_VALUE)

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if random.random() <= curr_rate:
                self._action_history.append(t_point)
                return True
            else:
                return False


class Eye2(Neuron):
    """
    Eye class to observe the environment, subclass of Neuron, has eye sight as 2 pixels
    """

    def __init__(self, direction, input_filter=None, gain=None, input_type=None, baseline_rate=None,
                 refractory_period=None):
        """
        for a fish occupies 3x3 space, consider the eyes are in the outer rim of the body (the 8 pixels surrounding the
        central pixel. Each pixel is an eye, receiving the input from the closest 6 pixels in the environment.
        for example:

        fish (1) in the environment(0):
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        eye (2) in the northwest connor is:
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0
        0 0 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        it receive inputs from pixels labelled as 3 in the environment:
        3 3 0 0 0 0 0
        3 3 3 0 0 0 0
        0 3 2 1 1 0 0
        0 0 1 1 1 0 0
        0 0 1 1 1 0 0
        0 0 0 0 0 0 0
        0 0 0 0 0 0 0

        the inputs from the environment (1x3 array) will be filtered by a array with same size, to generate
        a single value as the base of its input. this value will be multiplied by a float number gain to generate
        final input probability

        :param direction: the aim of the eye, should be one of the following, 'north', 'south', 'east', 'west',
                          'northwest', 'northeast', 'southwest', 'southeast'
        :param baseline_rate: float, probablity of a action per time unit.
        :param refractory_period: float, refractory_period in time unit
        :param input_type: str, type of the input the eye receives, should be one of 'terrain', 'food', 'fish',
               default: 'terrain'
        """

        if direction in ['north', 'south', 'east', 'west', 'northwest', 'northeast', 'southwest', 'southeast']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['north', 'south', 'east', 'west', "
                              "'northwest', 'northeast', 'southwest', 'southeast'].")

        if input_filter is None:
            self._input_filter = EYE2_INPUT_FILTER
        else:
            self._input_filter = input_filter.astype(np.float)

        if gain is None:
            self._gain = 0.001
        else:
            self._gain = float(gain)

        if input_type is None:
            self._input_type = 'terrain'
        elif input_type in ['terrain', 'food', 'fish']:
            self._input_type = input_type
        else:
            raise(ValueError, 'Eye2: type should be one of the following: "terrain", "food", "fish".')

        if baseline_rate is None:
            curr_baseline_rate = EYE_BASELINE_RATE
        else:
            curr_baseline_rate = float(baseline_rate)

        if refractory_period is None:
            curr_refractory_period = EYE_REFRACTORY_PERIOD
        else:
            curr_refractory_period = int(refractory_period)

        super(Eye2, self).__init__(baseline_rate=curr_baseline_rate, refractory_period=curr_refractory_period)

    def __str__(self):
        return 'littlefish.brain.Eye2 object'

    def _get_input_pixels(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: the 1d array with the values of the 3 pixels the eye is suppose to look at. pixels out of the terrain_map
        range will be returned as border_value
        """

        if len(position) != 2:
            raise (ValueError, 'Eye2: position should have 2 elements.')

        if isinstance(position[0], int) and isinstance(position[1], int):
            self._position = position
        else:
            raise (ValueError, 'Eye2: Elements in position should both be integers.')

        if len(input_map.shape) != 2:
            raise (ValueError, 'Eye2: terrain_map should a 2-d array.')

        if position[0] < 0 or position[0] >= input_map.shape[0] or \
                position[1] < 0 or position[1] >= input_map.shape[1]:
            raise (ValueError, 'Eye2: position out of range.')

        if self._direction == 'east':
            ind = [[position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] + 1, position[1] + 2],
                   [position[0], position[1] + 2],
                   [position[0] - 1, position[1] + 2]]
        elif self._direction == 'northeast':
            ind = [[position[0], position[1] + 1],
                   [position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] + 2],
                   [position[0] - 2, position[1] + 2],
                   [position[0] - 2, position[1] + 1]]
        elif self._direction == 'north':
            ind = [[position[0] - 1, position[1] + 1],
                   [position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0] - 2, position[1] + 1],
                   [position[0] - 2, position[1]],
                   [position[0] - 2, position[1] - 1]]
        elif self._direction == 'northwest':
            ind = [[position[0] - 1, position[1]],
                   [position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] - 2, position[1] - 1],
                   [position[0] - 2, position[1] - 2],
                   [position[0] - 1, position[1] - 2]]
        elif self._direction == 'west':
            ind = [[position[0] - 1, position[1] - 1],
                   [position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] - 1, position[1] - 2],
                   [position[0], position[1] - 2],
                   [position[0] + 1, position[1] - 2]]
        elif self._direction == 'southwest':
            ind = [[position[0], position[1] - 1],
                   [position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] - 2],
                   [position[0] + 2, position[1] - 2],
                   [position[0] + 2, position[1] - 2]]
        elif self._direction == 'south':
            ind = [[position[0] + 1, position[1] - 1],
                   [position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0] + 2, position[1] - 1],
                   [position[0] + 2, position[1]],
                   [position[0] + 2, position[1] + 1]]
        elif self._direction == 'southeast':
            ind = [[position[0] + 1, position[1]],
                   [position[0] + 1, position[1] + 1],
                   [position[0], position[1] + 1],
                   [position[0] + 2, position[1] + 1],
                   [position[0] + 2, position[1] + 2],
                   [position[0] + 1, position[1] + 2]
                   ]
        else:
            raise (ValueError, "Eye2: direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

        # print(ind)

        input_pixels = []

        for cor in ind:
            if cor[0] < 0 or cor[0] >= input_map.shape[0] or cor[1] < 0 or cor[1] >= input_map.shape[1]:
                input_pixels.append(border_value)
            else:
                input_pixels.append(input_map[cor[0], cor[1]])

        return np.array(input_pixels)

    def _get_input(self, input_map, position, border_value=EYE_BORDER_VALUE):
        """
        :return: calculate real time input from the visual field
        """
        input_pixels = self._get_input_pixels(input_map, position, border_value=EYE_BORDER_VALUE)
        probability_input = self._gain * np.sum(input_pixels * self._input_filter)

        return probability_input

    def get_position(self, body_position):
        """
        :param body_position: tuple of two ints, (row, col)
        :return: eye position given body position accroding its direction
        """
        if len(body_position) != 2:
            raise (ValueError, 'Eye2: body_position should contain two elements.')

        if (not isinstance(body_position[0], int)) or (not isinstance(body_position[1], int)):
            raise (ValueError, 'Eye2: body_position should contain two integers.')

        if self._direction == 'east':
            return body_position[0], body_position[1] + 1
        elif self._direction == 'northeast':
            return body_position[0] - 1, body_position[1] + 1
        elif self._direction == 'north':
            return body_position[0] - 1, body_position[1]
        elif self._direction == 'northwest':
            return body_position[0] - 1, body_position[1] - 1
        elif self._direction == 'west':
            return body_position[0], body_position[1] - 1
        elif self._direction == 'southwest':
            return body_position[0] + 1, body_position[1] - 1
        elif self._direction == 'south':
            return body_position[0] + 1, body_position[1]
        elif self._direction == 'southeast':
            return body_position[0] + 1, body_position[1] + 1
        else:
            raise(ValueError, "Eye2: direction should be one of the following: ['north', 'south', 'east', 'west', "
                               "'northwest', 'northeast', 'southwest', 'southeast'].")

    def get_input_type(self):
        return self._input_type

    def act(self, t_point, position, input_map, border_value=EYE_BORDER_VALUE):
        """
        evaluate if the eye neuron will fire at given time point
        :param t_point: int, current time point as the index of time unit axis
        :param position: tuple of two ints, (row, col),  position of the eye
        :param input_map: binary 2-d map, for now it should only contain 0s and 1s
        :param border_value: int, default 1, value for pixels outside the terrain_map
        :return: bool, True: fire; False: quite
        """

        probability_input = self._get_input(input_map, position, border_value=EYE_BORDER_VALUE)

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if random.random() <= curr_rate:
                self._action_history.append(t_point)
                return True
            else:
                return False


class Muscle(Neuron):
    """
    muscle class for determining the motion of the fish. Subclass of Neuron class
    """

    def __init__(self, direction, baseline_rate=MUSCLE_BASELINE_RATE, refractory_period=MUSCLE_REFRACTORY_PERIOD):

        if direction in ['east', 'north', 'west', 'south']:
            self._direction = direction
        else:
            raise(ValueError, "direction should be one of the following: ['east', 'north', 'west', 'south'].")

        super(Muscle, self).__init__(baseline_rate=baseline_rate, refractory_period=refractory_period)

    def __str__(self):
        return 'littlefish.brain.Muscle object'

    def act(self, t_point, probability_input=0., probability_base=None):
        """
        evaluate if the muscle will try to move the fish or not
        :param t_point: int, current time point as the index of time unit axis
        :param probability_input: float, summed connection inputs, as add on to baseline_rate
        :param probability_base: float, a random number no less than 0 and less than 1, to determine if the neuron
                                 is going to act or not, if None, a random number will be generated by
                                 random.random()
        :return: no attempt: False
                 attempt: movement vector, tuple of two ints
        """

        if probability_base is None:
            probability_base = random.random()

        if probability_base < 0. or probability_base >= 1.:
            raise (ValueError, 'probability_base should be no less than 0 and less than 1.')

        if len(self._action_history) > 0 and t_point - self._action_history[-1] < self._refractory_period:
            return False
        else:
            curr_rate = self._baseline_rate + probability_input
            if probability_base <= curr_rate:
                self._action_history.append(t_point)
                # print(t_point)
                if self._direction == 'east':
                    return 0, 1
                elif self._direction == 'north':
                    return -1, 0
                elif self._direction == 'west':
                    return 0, -1
                elif self._direction == 'south':
                    return 1, 0
                else:
                    raise(ValueError, "self.direction should be one of the following: "
                                      "['east', 'north', 'west', 'south'].")
            else:
                return False


class Connection(object):
    """
    synaptic connection between two neurons
    """

    def __init__(self, latency=CONNECTION_LATENCY, amplitude=CONNECTION_AMPLITUDE, rise_time=CONNECTION_RISE_TIME,
                 decay_time=CONNECTION_DECAY_TIME):
        """

        :param latency: int, temporal latency from presynaptic neuron action to the postsynaptic effect onset, number
                        of time units
        :param amplitude: float, peak change of the firing rate in the postsynaptic neuron, probablity of a action per
                          time unit. can be positive (excitatiory) or negative (inhibitory)
        :param rise_time: int, temporal duration from onset to peak, number of time units
        :param decay_time: int, temporal duration from peak to baseline, number of time units
        """

        if latency is not None:
            if not isinstance(latency, int):
                raise (ValueError, 'latency should be an integer.')
            self._latency = latency

        if amplitude is not None:
            self._amplitude = float(amplitude)

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise (ValueError, 'rise_time should be an integer.')
            self._rise_time = rise_time

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise (ValueError, 'decay_time should be an integer.')
            self._decay_time = decay_time

        self._generate_psp()

    def __str__(self):
        return 'littlefish.brain.Connection object'

    def _generate_psp(self):
        """
        generate post synaptic probability wave form
        """

        self._psp = np.zeros(self._latency + self._rise_time + self._decay_time)
        self._psp[self._latency: self._latency + self._rise_time] = self._amplitude * \
            (np.arange(self._rise_time) + 1).astype(np.float32) / float(self._rise_time)
        self._psp[-self._decay_time:] = self._amplitude * \
            (np.arange(self._decay_time, 0, -1) - 1).astype(np.float32) / float(self._decay_time)

    def get_psp(self):
        return self._psp

    def set_params(self, latency=None, amplitude=None, rise_time=None, decay_time=None):
        """
        set new parameters and regenerate psp waveform

        :param latency: int, number of time units for time delay
        :param amplitude: float, peak probability
        :param rise_time: int, number of time units to rise to peak
        :param decay_time: int, number of time units to decay to baseline
        """

        changed = False

        if latency is not None:
            if not isinstance(latency, int):
                raise (ValueError, 'latency should be an integer.')
            self._latency = latency
            changed = True

        if amplitude is not None:
            self._amplitude = float(amplitude)
            changed = True

        if rise_time is not None:
            if not isinstance(rise_time, int):
                raise (ValueError, 'rise_time should be an integer.')
            self._rise_time = rise_time
            changed = True

        if decay_time is not None:
            if not isinstance(decay_time, int):
                raise (ValueError, 'decay_time should be an integer.')
            self._decay_time = decay_time
            changed = True

        if changed:
            self._generate_psp()
        else:
            print('Brain.Connection: no parameter has been changed. Do nothing.')

    def act(self, t_point, postsynaptic_input):
        """
        if the presynaptic neuron fires at the 'time_point', a psp wave form will be generated and add to the
        input array of the postsynaptic neuron
        :param t_point: int, current time point as the index of time unit axis
        :param postsynaptic_input: 1-d array of floats
        :return:
        """
        psp_end = t_point + len(self._psp)
        if psp_end <= len(postsynaptic_input):
            postsynaptic_input[t_point: psp_end] += self._psp
        else:
            postsynaptic_input[t_point:] += self._psp[:len(postsynaptic_input) - t_point]


class Brain(object):
    """
    brain class, the neural network from eye to muscle

    a 'brain' has a couple of sets of 8 eyes (brain.Eye object, each at each border pixel of the body). each set of
    eyes are receiving inputs from different objects. i.e. one set of eyes will look at land/water, another set of eyes
    will look for food, another set of eyes will look for other fish.

    a 'brain' has 4 invisible muscles (brain.Muscle object, each controlling the movement in each direction).

    between eyes and muscles are a neural network consists of neurons (brain.Neuron object) and connections
    (brain.Connections object). Number of layers and number of neurons can be specified.
    """

    def __init__(self, neurons_df=None, connections_df=None):
        """

        :param neurons_df:
        :param connections_df:
        """

        if neurons_df is None:
            neurons_df = self.generate_default_neurons_df()
            self._generate_neurons(neurons_df)
        else:
            self._generate_neurons(neurons_df)

        if connections_df is None:
            self._generate_connections(self.generate_default_connections_df(neurons_df))
        else:
            self._generate_connections(connections_df)

        self._generate_connection_map()

        self._psp_waveforms = None

        self.check_integrity()

    def __str__(self):
        return 'littlefish.brain.Brain object'

    def _generate_neurons(self, neurons_df, verbose_level=1):
        """
        generate a dataframe containing actual Neuron objects from a dataframe containing neuron parameters.
        assign it to self._neurons
        """

        self._neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'neuron'])

        layer_num = int(round(max(neurons_df['layer']))) + 1

        params = neurons_df.columns.values.tolist()

        for i, row in neurons_df.iterrows():

            if int(row['layer']) == 0: #  eye layer

                curr_ind = int(row['neuron_ind'])
                curr_dir, curr_type = self.get_eye_type(curr_ind)

                if 'eye2_input_filter' not in params:
                    eye2_input_filter = EYE2_INPUT_FILTER
                else:
                    eye2_input_filter = row['eye_input_filter']

                if 'eye_gain' not in params:
                    eye_gain = EYE_GAIN
                else:
                    eye_gain = float(row['eye_gain'])

                if 'baseline_rate' not in params:
                    eye_baseline_rate = EYE_BASELINE_RATE
                else:
                    eye_baseline_rate = float(row['baseline_rate'])

                if 'refractory_period' not in params:
                    eye_refractory_period = EYE_REFRACTORY_PERIOD
                else:
                    eye_refractory_period = int(row['refractory_period'])

                self._neurons.loc[i] = \
                    [row['layer'],
                     row['neuron_ind'],
                     Eye2(direction=curr_dir,
                          input_filter=eye2_input_filter,
                          gain=eye_gain,
                          input_type=curr_type,
                          baseline_rate=eye_baseline_rate,
                          refractory_period=eye_refractory_period)]

                # print(row['layer'], 'eye')

            elif int(row['layer']) == layer_num - 1: #  muscle layer

                curr_ind = int(row['neuron_ind'])
                curr_dir = self.get_muscle_direction(curr_ind)

                if 'baseline_rate' not in params:
                    muscle_baseline_rate = MUSCLE_BASELINE_RATE
                else:
                    muscle_baseline_rate = row['baseline_rate']

                if 'refractory_period' not in params:
                    muscle_refractory_period = MUSCLE_REFRACTORY_PERIOD
                else:
                    muscle_refractory_period = row['refractory_period']

                self._neurons.loc[i] = \
                    [row['layer'],
                     row['neuron_ind'],
                     Muscle(direction=curr_dir,
                            baseline_rate=muscle_baseline_rate,
                            refractory_period=muscle_refractory_period)]

                # print(row['layer'], 'muscle')

            else:  # hidden layer
                if 'baseline_rate' not in params:
                    neuron_baseline_rate = NEURON_BASELINE_RATE
                else:
                    neuron_baseline_rate = row['baseline_rate']

                if 'refractory_period' not in params:
                    neuron_refractory_period = NEURON_REFRACTORY_PERIOD
                else:
                    neuron_refractory_period = row['refractory_period']

                self._neurons.loc[i] = \
                    [row['layer'],
                     row['neuron_ind'],
                     Neuron(baseline_rate=neuron_baseline_rate,
                            refractory_period=neuron_refractory_period)]

                # print(row['layer'], 'neuron')

        self._neurons['layer'] = self._neurons['layer'].astype(np.uint32)
        self._neurons['neuron_ind'] = self._neurons['neuron_ind'].astype(np.uint32)

        if verbose_level == 0:
            print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.\n')
        elif verbose_level == 1:
            print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.')
            layer_num = max(self._neurons['layer']) + 1
            for layer in range(layer_num):
                layer_name = self.get_layer_name(layer, layer_num)
                neuron_num = len(self._neurons[self._neurons.layer == layer])
                print(layer_name + ' : ' + str(neuron_num) + ' neurons.')
        elif verbose_level == 2:
            print('\nBrain: self._neurons dataframe with ' + str(len(self._neurons)) + ' neurons has been generated.')
            print(self._neurons)

    def _generate_connections(self, connections_df, verbose_level=0):
        """
        generate a dataframe containing actual Connection objects from a dataframe containing connection parameters.
        assign it to self._connections
        """
        self._connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'connection'])
        for i, row in connections_df.iterrows():

            if 'latency' not in connections_df.columns.values.tolist():
                latency = CONNECTION_LATENCY
            else:
                latency = int(row.latency)

            if 'amplitude' not in connections_df.columns.values.tolist():
                amplitude = CONNECTION_AMPLITUDE
            else:
                amplitude = float(row.amplitude)

            if 'rise_time' not in connections_df.columns.values.tolist():
                rise_time = CONNECTION_RISE_TIME
            else:
                rise_time = int(row.rise_time)

            if 'decay_time' not in connections_df.columns.values.tolist():
                decay_time = CONNECTION_DECAY_TIME
            else:
                decay_time = int(row.decay_time)

            self._connections.loc[i] = [row.presynaptic_ind, row.postsynaptic_ind,
                                        Connection(latency, amplitude, rise_time, decay_time)]

        self._connections['presynaptic_ind'] = self._connections['presynaptic_ind'].astype(np.uint32)
        self._connections['postsynaptic_ind'] = self._connections['postsynaptic_ind'].astype(np.uint32)

        if verbose_level == 0:
            print('\nBrain: self._connections dataframe with ' + str(len(self._connections)) +
                  ' connections has been generated.')
        if verbose_level == 1:
            print('\nBrain: self._connections dataframe with ' + str(len(self._connections)) +
                  ' neurons has been generated.')
            print(self._connections)

    def get_neurons(self):
        return self._neurons

    @property
    def layer_num(self):
        return int(round(max(self._neurons['layer']))) + 1

    def get_connections(self):
        return self._connections

    def has_action_histories(self):
        for neuron in self._neurons['neuron']:
            if len(neuron.get_action_history()) > 0:
                return True
        return False

    def has_psp_waveforms(self):
        if self._psp_waveforms is not None:
            return True
        else:
            return False

    def has_connection_map(self):
        if not hasattr(self, '_connection_map'):
            return False
        elif self._connection_map is None:
            return False
        else:
            return True

    def generate_empty_psp_waveforms(self):
        if self.has_psp_waveforms():
            raise (ValueError, 'Brain: can not generate empty psp waveforms, psp waveforms already exist.')

        self._psp_waveforms = {}

        waveform_count = 0
        for i in range(len(self._neurons)):
            if self._neurons.loc[i, 'layer'] > 0:
                self._psp_waveforms.update({i: np.zeros(SIMULATION_LENGTH, dtype=np.float32)})

        print('\nBrain: empty psp waveforms created. number of waveforms: ' + str(len(self._psp_waveforms)) + '; length '
              'of waveforms: ' + str(SIMULATION_LENGTH) + ' time units.')

    def _generate_connection_map(self):
        """
        map from presynaptic neuron index to (connection index, postsynaptic neuron index) pair

        :return dictionary,
        {presynaptic neuron ind in self._neurons: a list of tuple (connection index,
                                                                   postsynaptic neuron index in self._neurons)}

         this dictionary will be stalled as self._connection_map

         the information in self._connection_map is redundant given self._neurons and self._connections.
         But with this generated once and installed in memory, the simulation can be much faster (hopefully)
        """
        self._connection_map = {}

        presynaptic_indices = np.unique(self._connections.loc[:, 'presynaptic_ind'])

        for presynaptic_ind in presynaptic_indices:
            postsynaptic_pairs = []
            for j in range(len(self._connections)):
                if self._connections.loc[j, 'presynaptic_ind'] == presynaptic_ind:
                    postsynaptic_pairs.append((j, self._connections.loc[j, 'postsynaptic_ind']))
            self._connection_map.update({presynaptic_ind: postsynaptic_pairs})

        print('\nBrain: connection map generated.')
        # print self._connection_map

    def check_integrity(self):
        """
        check integrity of object data structure
        """

        print('\nBrain: checking integrity of attrbitue data structure ...')

        if not util.check_df_index(self._neurons):
            raise(ValueError, 'Brain: the indices of self._neurons are not starting at 0 and increasing with step 1.')
        else:
            print('Brain: the indices of self._neurons are starting at 0 and increasing with step 1. PASS.')

        layer = 0
        ind = -1
        for i, neuron in self._neurons.iterrows():
            curr_layer = int(round(neuron['layer']))
            curr_neuron_ind = neuron['neuron_ind']
            if curr_layer < layer:
                raise(ValueError, 'Brain: the "layer" in self._neurons is not in ascending order.')
            elif curr_layer == layer:
                if curr_neuron_ind != ind + 1:
                    raise(ValueError, 'Brain: the "neuron_ind" in self._neurons is not in ascending by step 1 for each '
                                      '"layer"')
                else:
                    ind += 1
            else:
                layer = curr_layer
                if curr_neuron_ind != 0:
                    raise(ValueError, 'Brain: the "neuron_ind" in self._neurons does not start with 0 for each "layer".')
                ind = 0

            if curr_layer == 0:  # eye layer
                if not (str(neuron['neuron']) == 'littlefish.brain.Eye object' or \
                        str(neuron['neuron']) == 'littlefish.brain.Eye2 object'):
                    raise(ValueError, 'Brain: non-eye object in eye layer.')
            elif curr_layer == self.layer_num - 1:  # muscle layer
                if not str(neuron['neuron']) == 'littlefish.brain.Muscle object':
                    raise(ValueError, 'Brain: non-muscle object in muscle layer.')
            else:  # hidden layer
                if not str(neuron['neuron']) == 'littlefish.brain.Neuron object':
                    raise(ValueError, 'Brain: non-neuron object in hidden layer.')

        print('Brain: the "layer" of self._neurons is in a non-descending order. PASS')
        print('Brain: the "neuron_ind" of self._neurons for each layer is ascending from 0 by step 1. PASS')
        print('Brain: eyes in eye layer, muscles in muscle layer, neurons in hidden layer. PASS')

        if not util.check_df_index(self._connections):
            raise(ValueError, 'Brain: the indices of self._connections are not starting at 0 and increasing with '
                              'step 1.')
        else:
            print('Brain: the indices of self._connections are starting at 0 and increasing with step 1. PASS.')

        for i, connection in self._connections.iterrows():
            if self._neurons.loc[connection['presynaptic_ind'], 'layer'] + 1 != \
                    self._neurons.loc[connection['postsynaptic_ind'], 'layer']:
                raise(ValueError, 'Brain: the ' + str(i) + 'th connection in self._connections does not represent a '
                                                           'true pre-post synaptic connection')
        print('Brain: all connections in self._connections represent true pre-post synaptic connection. PASS')

        presynaptic_ind = 0
        for i, connection in self._connections.iterrows():
            curr_presynaptic_ind = connection['presynaptic_ind']
            if curr_presynaptic_ind == presynaptic_ind:
                pass
            elif curr_presynaptic_ind == presynaptic_ind + 1:
                presynaptic_ind = curr_presynaptic_ind
            else:
                raise(ValueError, 'Brain: "presynaptic_ind" of self._connections is not non-descending from 0 by '
                                  'step 1.')
        print('Brain: "presynaptic_ind" of self._connections is non-descending from 0 by step 1. PASS')

        connection_map_keys = self._connection_map.keys()
        connection_map_keys.sort()
        if not np.array_equal(connection_map_keys, self.get_all_presynaptic_neuron_indices()):
            raise(ValueError, 'Brain: keys in self._connection_map do not represent all presynaptic neurons in '
                              'self._neurons.')
        else:
            print('Brain: keys in self._connection_map do not represent all presynaptic neurons in '
                  'self._neurons. PASS')

        for pre, value in self._connection_map.items():
            conn = [v[0] for v in value]
            post = [v[1] for v in value]
            post.sort()
            pre_layer = self._neurons.loc[pre, 'layer']
            if not np.array_equal(post, self.get_neuron_indices(pre_layer + 1)):
                raise(ValueError, 'Brain: the values in self._connection_map do not represent all postsynaptic neurons '
                                  'of the presynaptic neuron.')
            for i, conn_ind in enumerate(conn):
                if self._connections.loc[conn_ind, 'presynaptic_ind'] != pre or \
                        self._connections.loc[conn_ind, 'postsynaptic_ind'] != post[i]:
                    raise(ValueError, 'Brain: the values in self._connection_map do not match intended '
                                      'pre-post synaptic connections.')
        print('Brain: the values in self._connection_map represent all postsynaptic neurons of the presynaptic '
              'neuron. PASS')
        print('Brain: the values in self._connection_map match intended pre-post synaptic connections. PASS')

        if not self.has_psp_waveforms():
            print('Brain: self._psp_waveforms is None. Please use self.generate_empty_psp_waveforms() to generate psp '
                  'waveforms before simulation.')
        else:
            psp_waveform_keys = self._psp_waveforms.keys()
            psp_waveform_keys.sort()
            if not np.array_equal(psp_waveform_keys, self.get_all_postsynaptic_neuron_indices()):
                raise(ValueError, 'Brain: the keys of self._psp_waveforms do not represent all postsynaptic neurons '
                                  'in self._neurons.')
            else:
                print('Brain: the keys of self._psp_waveforms do represent all postsynaptic neurons in '
                      'self._neurons. PASS')

        print('Brain: integrity checking finished. All pass.\n')

    def act(self, t_point, body_position, terrain_map, food_map=None, fish_map=None):
        """
        :param t_point: int, current time stamp of time unit axis
        :param body_position: tuple of two ints, (row, col), current position of body center of the fish
        :param terrain_map: 2d array, with only 0s (water) and 1s (land). represents the land scape of the world
        :param food_map: 2d array, with only 0s (no food) and 1s (food). represents the distribution of food
        :return: movement attemps: tuple of 2 ints, represting the movement attempt, be careful, this may not
                                   represent the actual movement, it will be evaluated by the fish object (fish class)
                                   containing this brain to see if the movement is possible. if the fish is hitting
                                   the edge the world map, then the it will not move out of the map
                                   None: no movement has been attempted,
        """
        if len(body_position) != 2:
            raise (ValueError, 'body_position should contain two elements.')

        if (not isinstance(body_position[0], int)) or (not isinstance(body_position[1], int)):
            raise (ValueError, 'body_position should contain two integers.')

        if len(terrain_map.shape) != 2:
            raise(ValueError, 'terrain_map should be a 2-d array.')

        if not np.issubdtype(terrain_map.dtype, np.integer):
            raise(ValueError, 'dtype of terrain_map should be integer.')

        if np.max(terrain_map) > 1 or np.min(terrain_map) < 0:
            raise(ValueError, 'terrain_map should only contain 0s and 1s.')

        if body_position[0] < 1 or body_position[0] > terrain_map.shape[0] - 2 or \
            body_position[1] < 1 or body_position[1] > terrain_map.shape[1] - 2:
            raise(ValueError, 'body_position out of the range.')

        if not self.has_psp_waveforms():
            self.generate_empty_psp_waveforms()

        movement_attempt = [0, 0]

        for i, neuron in self._neurons.iterrows():

            if neuron['layer'] == 0:  # eye layer
                curr_eye = neuron['neuron']
                curr_eye_pos = curr_eye.get_position(body_position=body_position)

                if curr_eye.get_input_type() == 'terrain':
                    is_fire = curr_eye.act(t_point=t_point, position=curr_eye_pos, input_map=terrain_map)
                elif curr_eye.get_input_type() == 'food':
                    if food_map is not None:
                        is_fire = curr_eye.act(t_point=t_point, position=curr_eye_pos, input_map=food_map)
                    else:
                        is_fire = False
                elif curr_eye.get_input_type() == 'fish':
                    if fish_map is not None:
                        is_fire = curr_eye.act(t_point=t_point, position=curr_eye_pos, input_map=fish_map)
                    else:
                        is_fire = False
                else:
                    raise(ValueError, 'Brain: the input_type of eye should be one of the following:'
                                      '"terrain", "food" or "fish".')

                if is_fire:  # the current eye fires
                    # print('eye spike')
                    self.neuron_fire(neuron_ind=i, t_point=t_point)

            elif neuron['layer'] < self.layer_num - 1:  # hidden layer
                curr_neuron = neuron['neuron']
                is_fire = curr_neuron.act(t_point=t_point, probability_input=self._psp_waveforms[i][t_point])
                if is_fire:
                    # print('neuron spike')
                    self.neuron_fire(neuron_ind=i, t_point=t_point)

            elif neuron['layer'] == self.layer_num - 1:  # muscle layer
                curr_muscle = neuron['neuron']
                curr_movement_attempt = curr_muscle.act(t_point=t_point, probability_input=self._psp_waveforms[i][t_point])
                if curr_movement_attempt:
                    # print('muscle spike')
                    movement_attempt[0] += curr_movement_attempt[0]
                    movement_attempt[1] += curr_movement_attempt[1]

            else:
                raise(ValueError, 'Brain: neuron at index' + str(i) + ' has invalid layer location.')

        return movement_attempt

    def neuron_fire(self, neuron_ind, t_point):
        """
        updata all corresponding psp waveforms when a presynaptic neuron (only in eye layer and hidden layer) fires
        :param neuron_ind: int, the index of presynaptic neuron in self._neurons
        :param t_point: int, time point in time unit axis of the action
        :return: None
        """
        if not self.has_psp_waveforms:
            raise(ValueError, 'Brain: cannot find self._psp_waveforms, please generate them first.')

        if not self.has_connection_map():
            raise(ValueError, 'Brain: cannot find self._connection_map, please generate it first.')

        neuron_layer = int(round(self._neurons.loc[neuron_ind, 'layer']))

        if neuron_layer >= 0 and neuron_layer < self.layer_num -1:  # eye layer or hidden layer
            for postsynaptic_component in self._connection_map[neuron_ind]:
                curr_connection = self._connections.loc[postsynaptic_component[0], 'connection']
                curr_psp_waveform = self._psp_waveforms[postsynaptic_component[1]]
                curr_connection.act(t_point=t_point, postsynaptic_input=curr_psp_waveform)
        elif neuron_layer == self.layer_num -1:  # muscle layer
            print('Brain: a firing of a muscle has no effect on brain itself. Please use Muscle.act() method to '
                  'generate movement attempt.')
        else:
            raise(ValueError, 'Brain: neuron at index' + str(neuron_ind) + ' has invalid layer location.')

    def get_neuron_indices(self, layer):
        """
        get indices of all neurons in a specific layer
        """
        ind = self._neurons[self._neurons['layer'] == layer].index
        return ind.sort_values()

    def get_all_presynaptic_neuron_indices(self):
        """
        get indices of all presynaptic neurons
        """
        layer_num = int(max(self._neurons['layer'])) + 1
        ind = self._neurons[self._neurons['layer'] < layer_num -1].index
        return ind.sort_values()

    def get_all_postsynaptic_neuron_indices(self):
        """
        get indices of all postsynaptic neurons
        """
        ind = self._neurons[self._neurons['layer'] > 0].index
        return ind.sort_values()

    def _clear_psp_waveforms(self):
        if self.has_psp_waveforms():
            self._psp_waveforms = None
            print('Brain: all psp waveforms deleted.')
        else:
            print('Brain: no psp waveforms found. Do nothing.')

    def _clear_action_histories(self):
        if self.has_action_histories():
            for neuron in self._neurons['neuron']:
                neuron.reset_action_history([])
            print('Brain: action histories of all neurons have been deleted.')
        else:
            print('Brain: no action history is found for any neuron. Do nothing.')

    def clear_simulation_data(self):
        self._clear_psp_waveforms()
        self._clear_action_histories()

    def to_h5_group(self):
        pass

    @staticmethod
    def get_eye_type(ind):
        """
        given the neuron_ind in the eye layer return direction and input type of a specific eye
        :return: two strings, (direction, type)
        """
        direction_num = len(EYE_DIRECTIONS)
        return EYE_DIRECTIONS[ind % direction_num], EYE_INPUT_TYPES[ind // direction_num]

    @staticmethod
    def get_muscle_direction(ind):
        """
        given the neuron_ind in the muscle layer return direction of a specific muscle
        :return: string, direction of the muscle
        """
        direction_num = len(MUSCLE_DIRECTIONS)
        return MUSCLE_DIRECTIONS[ind % direction_num]

    @staticmethod
    def from_h5_group(h5_group):
        pass

    @staticmethod
    def get_layer_name(layer_ind, layer_num):
        """
        return name of a layer given the total number of layers and index of the layer
        """
        if layer_num < 3:
            raise(ValueError, 'layer_num should be no less than 3.')

        if layer_ind == 0:
            layer_name = 'eye layer'
        elif layer_ind == layer_num - 1:
            layer_name = 'muscle layer'
        else:
            layer_name = 'hidden layer ' + util.int2str(layer_ind, 2)
        return layer_name
    
    @staticmethod
    def generate_default_neurons_df():
        """
        generate and return a dataframe containing all neurons with default parameters
        """
        neurons = pd.DataFrame(columns=['layer', 'neuron_ind', 'baseline_rate', 'refractory_period'])

        ind = 0
        for i in range(8):
            neurons.loc[ind] = [0, i, EYE_BASELINE_RATE, EYE_REFRACTORY_PERIOD]
            ind += 1

        for i in range(8):
            neurons.loc[ind] = [1, i, NEURON_BASELINE_RATE, NEURON_REFRACTORY_PERIOD]
            ind += 1

        for i in range(4):
            neurons.loc[ind] = [2, i, MUSCLE_BASELINE_RATE, MUSCLE_REFRACTORY_PERIOD]
            ind += 1

        neurons['layer'] = neurons['layer'].astype(np.uint32)
        neurons['neuron_ind'] = neurons['neuron_ind'].astype(np.uint32)
        neurons['baseline_rate'] = neurons['baseline_rate'].astype(np.float64)
        neurons['refractory_period'] = neurons['refractory_period'].astype(np.uint64)

        return neurons

    @staticmethod
    def generate_default_connections_df(neurons_df):
        """
        from a dataframe containing parameters of all neurons, generate and return a dataframe containing all
        connections with default parameters
        """
        layer_num = np.max(neurons_df['layer']) + 1

        connections = pd.DataFrame(columns=['presynaptic_ind', 'postsynaptic_ind', 'latency', 'amplitude',
                                            'rise_time', 'decay_time'])

        ind = 0
        for i in range(len(neurons_df)):
            curr_presynaptic_layer = neurons_df.loc[i,'layer']
            if curr_presynaptic_layer < layer_num - 1:
                for j in range(len(neurons_df)):
                    if neurons_df.loc[j, 'layer'] == curr_presynaptic_layer + 1:
                        connections.loc[ind] = [i, j, CONNECTION_LATENCY, CONNECTION_AMPLITUDE, CONNECTION_RISE_TIME,
                                                CONNECTION_DECAY_TIME]
                        ind += 1

        connections['presynaptic_ind'] = connections['presynaptic_ind'].astype(np.uint32)
        connections['postsynaptic_ind'] = connections['postsynaptic_ind'].astype(np.uint32)

        return connections


if __name__ == '__main__':

    # =========================================================================================
    # neuron = Neuron()
    # for i in range(SIMULATION_LENGTH):
    #     neuron.act(i)
    # print(len(neuron.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # connection = Connection(amplitude=10, latency=5)
    # print(connection.get_psp())
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 50
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    # connection = Connection(amplitude=10, latency=5, rise_time=5, decay_time=10)
    # connection.act(2, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(4, postsynaptic_input)
    # print(postsynaptic_input)
    # connection.act(40, postsynaptic_input)
    # print(postsynaptic_input)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 5000
    # neuron_pre = Neuron(baseline_rate=0.005)
    # neuron_post = Neuron(baseline_rate=0.000)
    # connection = Connection(amplitude=1, latency=5, rise_time=1, decay_time=1)
    #
    # postsynaptic_input = np.zeros(SIMULATION_LENGTH)
    #
    # for i in range(SIMULATION_LENGTH):
    #
    #     is_firing = neuron_pre.act(i)
    #     if is_firing:
    #         connection.act(i, postsynaptic_input)
    #     neuron_post.act(i, probability_input=postsynaptic_input[i])
    #
    # spk_train_pre = neuron_pre.get_action_history()
    # spk_train_post = neuron_post.get_action_history()
    #
    # # print(postsynaptic_input)
    # print(len(spk_train_pre))
    # print(len(spk_train_post))
    #
    # ccg, t = util.discreat_crosscorrelation(np.array(spk_train_pre), np.array(spk_train_post))
    # plt.bar(t, ccg)
    # plt.show()
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # terrain_map = np.zeros((5, 5), dtype=np.uint8)
    # terrain_map[3, 3] = 1
    # print(terrain_map)
    #
    # eye = Eye(position=(2, 3), direction='south')
    # print(eye._get_input(terrain_map=terrain_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(i, terrain_map=terrain_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 20000
    # muscle = Muscle(direction='east', baseline_rate=0., refractory_period=5000)
    # movements = []
    # for i in range(SIMULATION_LENGTH):
    #     movement=muscle.act(i, probability_input=0.5, probability_base=0.1)
    #     if movement:
    #         movements.append(movement)
    # print(movements)
    # print(muscle.get_action_history())
    # =========================================================================================

    # =========================================================================================
    # brain = Brain()
    # neurons_df = brain.generate_default_neurons_df()
    # connections_df = brain.generate_default_connections_df(neurons_df)
    # =========================================================================================

    # =========================================================================================
    # SIMULATION_LENGTH = 100000
    #
    # terrain_map = np.zeros((5, 5), dtype=np.uint8)
    # terrain_map[3, 3] = 1
    # print(terrain_map)
    #
    # eye = Eye2(direction='south')
    # position = (2, 3)
    # print(eye._get_input_pixels(position=position, terrain_map=terrain_map))
    # print(eye._get_input(position=position, terrain_map=terrain_map))
    #
    # for i in range(SIMULATION_LENGTH):
    #     eye.act(t_point=i, position=position, terrain_map=terrain_map)
    # print(len(eye.get_action_history()))
    # =========================================================================================

    # =========================================================================================
    brain = Brain()
    # print(brain.has_action_histories())
    # brain._generate_empty_psp_waveforms()
    # print(brain.get_neuron_indices(2))
    # print(brain.get_all_presynaptic_neuron_indices())
    # print(brain.get_all_postsynaptic_neuron_indices())
    # print(brain.get_eye_type(13))
    # print(brain.layer_num)
    # =========================================================================================

    print('debug...')
